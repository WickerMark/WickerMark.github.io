[
  {
    "objectID": "posts/primes.html",
    "href": "posts/primes.html",
    "title": "Generating the nth Prime Number",
    "section": "",
    "text": "Project Euler #7\n\n\nIntroduction\nThe ability to generate prime numbers is important for a variety of tasks, most notably, cryptography, the RSA algorithm for instance, in psuedo-random number generation and benchmarking algorithms. This nth prime number generator is a spin on Problem #7 in Project Euler.\n\n\nSetting up the Problem\nNumpy will be used for the square root function later in the code.\nAn array used to store the prime numbers is created and the first two prime numbers are stored.\nNumber, the variable used to represent the current number to be checked if it is prime, is set to 3. This means that the counter, used to represent how many prime numbers have been found, is set to 2, since 3 is the second prime number.\n\nimport numpy as np\n\nprime_list = [2, 3]\nnumber = 3\ncounter = 2\n\nThe prime number to be generated can be set to anything, but for this example, I have used 1000. This means that the while loop will continue to iterate until the counter is no longer less than 1000.\n\n\nCalculating and Outputting the nth Prime Number\nThe variable number is first incremented by 2 (to emit all even numbers since these cannot be prime).\nA new variable, called prime, stores a boolean value which states if a number is prime or not. Initially, prime is set to True.\nA for loop is used to check if number is divisible by previous prime numbers.\nThe square root function is used here because if the index of the prime number to be checked is greater than the square root of the number, it is not a factor. If this statement is true, the code breaks out of the for loop.\nHere, I use the modulo operator to determine if the number has a remainder when dividing by previous prime numbers. If it does, the number is determined as a composite number, and so prime is set to False.\nThe final if statement is used such that if the number was determined to be prime, the counter would be incremented, and the number would be appended to the list of prime numbers so that future numbers can be checked against it.\nFinally, counter is cast as a string and concatenated to output the nth prime number.\n\nwhile counter &lt; 1000:\n    number += 2\n    prime = True\n    for i in prime_list:\n        if i &gt; np.sqrt(number):\n            break\n        elif number % i == 0:\n            prime = False\n            break\n    \n    if prime == True:\n        counter += 1\n        prime_list.append(number)\n        \nprint(\"The\", str(counter) + \"th prime number is\", number)\n\nThe 1000th prime number is 7919"
  },
  {
    "objectID": "posts/newton-raphson.html",
    "href": "posts/newton-raphson.html",
    "title": "Root Finding using the Newton-Raphson Method",
    "section": "",
    "text": "Introduction\nDeveloped in the 17th century by mathematicians Sir Isaac Newton and Joseph Raphson, the Newton-Raphson method is a powerful and efficient numerical technique for iterative root finding. It is based on the idea of linear approximation (tangent line approximation) and provides increasingly accurate estimates of the root. # Setting up the Problem The sympy library is used for symbolic differentiation. Numpy is used for the np.arange() function. Matplotlib is used to plot a graph to show the roots found.\n\nimport sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nTo begin, we will define f(x) and f’(x) symbolically. Next, we will convert these equations to numerical functions using the function sp.lambdify() to enter values of x into the function and first derivative.\n\n# Defines x for sympy\nx = sp.Symbol('x')\n\n# Defines f(x)\nf = 2 * x**3 + 2 * x**2 - 10 * x - 8\n\n# Calculating the symbolic derivative using sympy and defining f'(x)\nderivative = sp.diff(f, x)\n\n# Convert symbolic function and derivative to numerical functions using lambdify\nf_lambdified = sp.lambdify(x, f)\nderivative_lambdified = sp.lambdify(x, derivative)\n\nNext, we must set the parameters of the iterative method. The first parameter is a range of initial approximations of the roots which will be refined iteratively by the algorithm to find a better approximation of the root. The next parameter is a limit to the number of iterations that can occur in the for loop to determine the roots. This is so prevent the risk of non-convergence (so the loop does not continue infinitely). For this example, I used 1000 iterations, however, this could be changed to the preference and specification of the user. The final parameter is the tolerance, a small number that will determine if the root determined by the method is close enough to 0 to be considered a root. I have used 1e-6, but again, in reality, the user would change this to their preference.\n\n# Other parameters for the Newton-Raphson Method\n# Define the range of initial guesses to find multiple roots\ninitial_guesses = np.linspace(-4, 4, 10)\n# Maximum iteration\nmax_iterations = 1000\n# Tolerance\ntolerance=1e-6\n\n\n\nNewton-Raphson Method\nFirst, the initial guess is set as the current approximation for the root. Then, \\(f(x_n)\\) and \\(f'(x_n)\\) are calculated. To ensure no divide by zero errors occur, the value of the derivative is checked. The equation \\(x_{n+1}=x_n-\\frac{f(x_n)}{f'(x_n)}\\) is used to update the approximation of the root. Finally, if \\(|{x_{n+1}-x_n}|&lt;tolerance\\), then the y coordinate of the approximation is close enough to 0 that the function return the value of x to prevent non-convergence. Otherwise, the ‘next’ approximation is set to the current approximation.\n\n# Defines the function for the Newton-Raphson Method\ndef newtonraphson(f, derivative, x_0, max_iterations, tolerance):\n    # Sets the starting x value\n    x_n = x_0\n    for i in range(max_iterations):\n        fx_n = f_lambdified(x_n)\n        dfx_n = derivative_lambdified(x_n)\n        \n        # Ensures the prevention of a divide by zero error\n        if dfx_n == 0: \n            print(\"Zero derivative encountered. No solution found.\")\n            return None\n        \n        # Uses the equation to find the next x coordinate\n        x_next = x_n - (fx_n / dfx_n)\n\n        # Check if the result is within the desired tolerance\n        if abs(x_next - x_n) &lt; tolerance:\n            return x_next\n        \n        # Updates x\n        x_n = x_next\n\n\n\nOutputs and Plotting\nAn empty array of x and y coordinates is created for the purpose of plotting the roots on a graph for visualisation. For every guess in the list of inital guesses, the function to perform the Newton-Raphson method is called and passed the current inital guess. The root is then rounded to 10 decimal places. This is a fairly arbitrary value, and the user could set this to whatever they wanted. The if statement is used to ensure that duplicate roots are not considered. The x coordinates of the roots found are printed and are also appended to the empty array created earlier. 0 is appended to the y coordinate.\n\n# Creates empty array of x coordinates to plot the roots\nrootx = []\nrooty = []\n\n# Finds multiple roots using different initial guesses\nfor x_0 in initial_guesses:\n    # Calls the function\n    rootx_n = (newtonraphson(f, derivative, x_0, max_iterations, tolerance))\n    rootx_n = round(rootx_n, 10)\n\n    # If statement to avoid duplicates and ignore None results\n    if rootx_n is not None and rootx_n not in rootx:\n        # Prints the x coordinate of each root\n        print(\"Root: x =\", rootx_n)\n\n        # Updates x and y coordinate of root in the arrays\n        rootx.append(rootx_n)\n        rooty.append(0)\n\nRoot: x = -2.3913823806\nRoot: x = -0.7728655578\nRoot: x = 2.1642479385\n\n\nThe results of the program are very accurate. The results match the correct x coordinate of the roots to the ninth decimal place, which demonstrates the reliability of the method.\nA list of x and y coordinates for f(x) are created in order to plot the graph. The scatter function is used to plot the roots.\nThen, the parameters of the plot are set: the limit for the x axis, the creation of a grid, a solid line for the x axis, and also the legend to display labels.\nLastly, the graph is then displayed.\n\n# Creates an array of x coordinates and finds corresponding y coordinates \n# for plotting\nx = np.linspace(-4, 4, 100)\ny = f_lambdified(x)\n\n# Plots the curves\nplt.plot(x, y)\nplt.scatter(rootx, rooty, marker=\"x\", color=\"red\", label=\"Roots\")\n\n# Sets parameters of the plot and plots the curves\nplt.xlim(-4, 4)\nplt.ylim(-15, 15)\n\nplt.grid()\nplt.legend()\nplt.axhline(y=0, color=\"black\")\n\nplt.show()"
  },
  {
    "objectID": "posts/integration.html",
    "href": "posts/integration.html",
    "title": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule",
    "section": "",
    "text": "In order to compare Simpson’s Rule and Trapezium Rule for calculating the numerical integral, I have created two functions: the first function is a polynomial (specifically quartic) function, and the second function is trigonometric. Simpson’s Rule and Trapezium Rule will then be used to calculate the integral for each of these function. Each of the algorithms will also be timed to further compare them."
  },
  {
    "objectID": "posts/integration.html#imported-libraries",
    "href": "posts/integration.html#imported-libraries",
    "title": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule",
    "section": "Imported Libraries",
    "text": "Imported Libraries\nNumpy is used for trigonometric functions, specifically sin and cos. The timeit library is used to find the run time of each method, which will then be used to compare them.\n\nimport numpy as np\n\nimport timeit"
  },
  {
    "objectID": "posts/integration.html#defining-the-polynomial-and-trigonometric-functions",
    "href": "posts/integration.html#defining-the-polynomial-and-trigonometric-functions",
    "title": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule",
    "section": "Defining the Polynomial and Trigonometric Functions",
    "text": "Defining the Polynomial and Trigonometric Functions\nThe quartic function I used for this demonstration was \\(f(x)=x^4+5x^3-2x^2-10x-8\\) as shown below. The trigonometric function used was \\(f(x)=\\sin^3(x)+\\cos(x)\\). I used functions to define these expressions such that passing the value of x to the function would return \\(f(x)\\).\n\n# Defines the functions to be integrated\n\n# Polynomial (quartic) function\ndef f1(x):\n    return x**4 + 5 * x**3 - 2 * x**2 - 10 * x - 8\n\n# Trigonometric function\ndef f2(x):\n    return np.sin(x)**3 + np.cos(x)"
  },
  {
    "objectID": "posts/integration.html#setting-the-limits-and-number-of-intervals",
    "href": "posts/integration.html#setting-the-limits-and-number-of-intervals",
    "title": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule",
    "section": "Setting the Limits and Number of Intervals",
    "text": "Setting the Limits and Number of Intervals\nThe limits applied to the first integral are \\(a=-10\\) and \\(b=5\\) such that \\(\\int_{-10}^{5} x^5+5x^3-2x^2-10x-8 \\,dx\\). The limits applied to the second function are \\(a=0\\) and \\(b=\\pi\\) such that \\(\\int_{0}^{\\pi} \\sin^3(x)+\\cos(x) \\,dx\\). For the first function, each of the methods will have 1000 intervals, and for the second function, 10000 intervals will be used. This is somewhat fairer since the trigonometric function has more fluctuations and so a higher interval can help cature the integral more accurately, while also allowing for comparison between the methods at different intervals.\n\n# Sets the limits to integrate between\n# Function 1\na1 = -10\nb1 = 5\n\n# Function 2\na2 = 0\nb2 = np.pi\n\n# Number of intervals\n# Function 1\nn1 = 1000\n\n# Function 2\nn2 = 100000"
  },
  {
    "objectID": "posts/integration.html#calculating-the-integral",
    "href": "posts/integration.html#calculating-the-integral",
    "title": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule",
    "section": "Calculating the Integral",
    "text": "Calculating the Integral\nThe interval between each value of \\(x_i\\) is calculated using the equation \\(h=\\frac{b-a}{n}\\), where \\(h\\) is the interval.\nTwo empty arrays for coordinates of \\(f(x)\\) are created. The first array (list) will contain all the values of \\(f(x_i)\\) when \\(i\\) is even, and the second list will contain all the values of \\(f(x_i)\\) when \\(i\\) is odd.\nNext, \\(f(a)\\) and \\(f(b)\\) are calculated for further use.\nA for loop is used between \\(i=1\\) (the first value of \\(x_i\\)) and \\(n\\), the number of intervals.\nThe coordinate \\(x_i\\) is updated using the formula \\(x_i=a+ih\\). Then, \\(f(x_i)\\) is found.\nThe if statement is used to determine which list \\(x_i\\) belongs in. By using the modulo operator (%), we can find if there is a remainder when dividing by 2, and therefore if the value of \\(i\\) is odd or even.\nAfter the for loop is completed, and all the values of \\(f(x_i)\\) are sorted in the correct list, Simpson’s Rule is used to approximate the integral. Here is the formula: \\(\\int_{a}^{b} f(x) \\,dx\\approx\\frac{h}{3}[f(a)+4\\sum_{odd} f(x_i) +2\\sum_{even} f(x_i) +f(b)]\\).\n\n# Function to perform Simpson's Rule\ndef SimpsonsRule(f, a, b, n):\n    # Calculating the interval between each value of x\n    h = (b - a) / n\n\n    # Empty arrays for storing the f(x) values corresponding to odd and even i\n    fx_ieven = []\n    fx_iodd = []\n\n    # Setting the first term and calculating f(a) and f(b)\n    fa = f(a)\n    fb = f(b)\n\n    for i in range(1, n):\n        # Updates the current x coordinate and finds f(x)\n        x_i = a + i * h\n        fx_i = f(x_i)\n        \n        # Checks to see if i is odd or even and appends f(x)\n        if i % 2 == 0:\n            fx_ieven.append(fx_i)\n        else:\n            fx_iodd.append(fx_i)\n\n    # Calculation to approximate the value of the integral\n    I = (h/3) * (fa + 4 * sum(fx_iodd) + 2 * sum(fx_ieven) + fb)\n\n    return I"
  },
  {
    "objectID": "posts/integration.html#function-1",
    "href": "posts/integration.html#function-1",
    "title": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule",
    "section": "Function 1",
    "text": "Function 1\n\n# Starts run time timer\nstart = timeit.default_timer()\n\n\n# Calls function and outputs integral\nprint(\"Simpson's Rule: The Integral of Function 1 (Polynomial):\", SimpsonsRule(f1, a1, b1, n1))\n\nSimpson's Rule: The Integral of Function 1 (Polynomial): 8411.25000010125\n\n\n\n# Stops the timer\nstop = timeit.default_timer()\n\n# Calculates run time\nprint('Run Time for Function 1: ', stop - start)\n\nRun Time for Function 1:  0.024055900052189827"
  },
  {
    "objectID": "posts/integration.html#function-2",
    "href": "posts/integration.html#function-2",
    "title": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule",
    "section": "Function 2",
    "text": "Function 2\n\n# Starts run time timer\nstart = timeit.default_timer()\n\n\nprint(\"Simpson's Rule: The Integral of Function 2 (Trigonometric):\", SimpsonsRule(f2, a2, b2, n2))\n\nSimpson's Rule: The Integral of Function 2 (Trigonometric): 1.3333333333333337\n\n\n\n# Stops the timer\nstop = timeit.default_timer()\n\n# Calculates run time\nprint('Run Time for Function 2: ', stop - start)\n\nRun Time for Function 2:  0.23701390018686652"
  },
  {
    "objectID": "posts/integration.html#analysis",
    "href": "posts/integration.html#analysis",
    "title": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule",
    "section": "Analysis",
    "text": "Analysis"
  },
  {
    "objectID": "posts/integration.html#calculating-the-integral-1",
    "href": "posts/integration.html#calculating-the-integral-1",
    "title": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule",
    "section": "Calculating the Integral",
    "text": "Calculating the Integral\n\n# Trapezium Rule\ndef TrapeziumRule(f, a, b, n):\n    # Calculating the interval between each value of x\n    h = (b - a) / n\n\n    fa = f(a)\n    fb = f(b)\n\n    fx_ilist = []\n\n    for i in range(1, n):\n        x_i = a + h * i\n\n        fx_ilist.append(f(x_i))\n\n    I = (h / 2) * (fa + 2 * sum(fx_ilist) + fb)\n\n    return I"
  },
  {
    "objectID": "posts/integration.html#function-1-1",
    "href": "posts/integration.html#function-1-1",
    "title": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule",
    "section": "Function 1",
    "text": "Function 1\n\n# Starts run time timer\nstart = timeit.default_timer()\n\n\n# Calls and prints function\nprint(\"Trapezium Rule: The Integral of Function 1 (Polynomial):\", TrapeziumRule(f1, a1, b1, n1))\n\nTrapezium Rule: The Integral of Function 1 (Polynomial): 8411.312156224687\n\n\n\n# Stops the timer\nstop = timeit.default_timer()\n\n# Calculates run time\nprint('Run Time for Function 1: ', stop - start)\n\nRun Time for Function 1:  0.02195580000989139"
  },
  {
    "objectID": "posts/integration.html#function-2-1",
    "href": "posts/integration.html#function-2-1",
    "title": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule",
    "section": "Function 2",
    "text": "Function 2\n\n# Starts run time timer\nstart = timeit.default_timer()\n\n\nprint(\"Trapezium Rule: The Integral of Function 2 (Trigonometric)\", TrapeziumRule(f2, a2, b2, n2))\n\nTrapezium Rule: The Integral of Function 2 (Trigonometric) 1.3333333333333481\n\n\n\n# Stops the timer\nstop = timeit.default_timer()\n\n# Calculates run time\nprint('Run Time for Function 2: ', stop - start)\n\nRun Time for Function 2:  0.2439755001105368"
  },
  {
    "objectID": "posts/integration.html#analysis-1",
    "href": "posts/integration.html#analysis-1",
    "title": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule",
    "section": "Analysis",
    "text": "Analysis"
  },
  {
    "objectID": "posts/derivative.html",
    "href": "posts/derivative.html",
    "title": "A Numerical Method to Calculate the Derivative using the Central Difference Method and a Small Step, ϵ",
    "section": "",
    "text": "Introduction\nThe function created is based on the equation \\(f'(x)\\approx\\frac{f(x + \\epsilon)-f(x - \\epsilon)}{2\\epsilon}\\) to accurately approximate the first derivative using the central difference method and a small step. I have set the small step to \\(\\epsilon=1\\times10^{-8}\\), however, this can be modified to the specification of the user.\n\n\nSetting up the Problem\nTo begin the algorithm, the required libraries are imported, specifically numpy for trigonometric and logarithmic functions and matplotlib for the plotting.\nNext, the function to be differentiated is defined. For the purpose of this example, the function used is \\(f(x)=\\ln(x^2)\\sin(x)\\). The user can change the function to whatever may be required.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Creates the function\ndef f(x):\n    return np.log(x**2) * np.sin(x)\n\n\n\nCalculating the Derivative\nThis function finds the derivative using the central difference method and a small step, ϵ, at a given x coordinate. This is useful for plotting, because the desired array of x coordinates can be passed to the function to generate an f’(x) function for that set of values. For other algorithms, the gradient descent algorithm for instance, finding the derivative at a given x coordinate is useful for further calculations.\n\n# Function to differentiate\ndef derivative(f, x):\n    eps = 1e-8\n    der = (f(x + eps) - f(x - eps)) / (2 * eps)\n    \n    return der\n\n\n\nOutputting a Graph of the Derivative\nHere, np.linspace(-15, 15, 500) is used to create an equally spaced array of 500 x coordinates between x = -15 and x = 15. Then, for each x coordinate, a corresponding y coordinate is found by passing each x coordinate into the function.\n\n# Creates an array of x coordinates and finds corresponding y coordinates \n# for plotting\nx = np.linspace(-15, 15, 500)\ny = f(x)\n\nNow, list comprehension is used to apply the derivative function to each element \\(x_i\\) in \\(x\\). The result is then stored as a numpy array for plotting.\n\n# Differentiates x coordinates to create the graph of the first derivative\ndydx = np.array([derivative(f, xi) for xi in x])\n\nLastly, the curves f(x) and f’(x) are plotted and given appropriate labels.\nThen, the parameters of the plot are set, the limit for the x axis, the creation of a grid and also the legend to display labels.\nThis graph is then displayed.\n\n# Plots the curves\nplt.plot(x, y, label=\"f(x)\")\nplt.plot(x, dydx, label=\"f'(x)\")\n\n# Sets parameters of the plot and plots the curves\nplt.xlim(-15, 15)\nplt.grid()\nplt.legend()\n\nplt.show()\n\n\n\n\n\n\n\n\nThis algorithm has been curated for use in the gradient descent algorithm, which will be a future post."
  },
  {
    "objectID": "posts/cchallenge9.html",
    "href": "posts/cchallenge9.html",
    "title": "BPhO Computational Challenge 2024: Challenge 9: Creating a Projectile Model Incorporating Air Resistance Using Verlet Integration",
    "section": "",
    "text": "Introduction\nDISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo .\n\n\nSetting up the Problem\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\n\n\n# Input parameters\nangle = 35\nu = 50\ng = 9.81\nh = 100\nA = 0.002\nc_drag = 0.3\ndensity = 1\nm = 0.01\ndt = 0.01\n\n\n# Converts the angle to radians\ntheta = (angle * np.pi) / 180\n\n# Resloves forces into horizontal and vertical component\ncostheta = math.cos(theta)\nsintheta = math.sin(theta)\n\nux = u * costheta\nuy = u * sintheta\n\n\n\nNo Air Resistance\n\n# Calculates the range and time of flight of the projectile\nR = (u**2 / g) * (sintheta*costheta+costheta*math.sqrt(sintheta**2 + ((2 * g * h) / (u**2))))\ntflight = R / (u * costheta)\n\n# Time of flight phrase\nprint(\"Time of flight: \" + str(round(tflight, 2)) + \" s\")\n    \n# Range phrase\nprint(\"Range: \" + str(round(R, 2)) + \" m\")   \n\nTime of flight: 8.3 s\nRange: 340.05 m\n\n\n\n# Creates an empty arrary for the x and y coordinates of the trajectory\nx = []\ny = []\n\n# Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\nfor i in np.arange(0, tflight, 0.01):\n    t = i\n    x.append(ux * t)\n    T = t * t\n    y.append(h + (uy * t) - (0.5 * g * T))            \n\n\n# Apogee calculation\napy = (0 - (uy*uy)) / (2 * g * -1) + h\ny_graph = apy + apy * 0.01\n\n\n\nAir Resistance\n\n# Calculation for k\nk = (0.5 * c_drag * density * A) / m\n\n\n# Creates arrays for air resistance x and y values\nx_plot = []\ny_plot = []\n\n# Sets initial x and y values\nd_x = 0\nd_y = h\n\n# Adds initial x and y values to the arrays\nx_plot.append(d_x)\ny_plot.append(d_y)\n\n# Verlet method to update the acceleration, velocity and position of the projectile after each discrete timestep\nn = 0\nt_drag = 0\nwhile y_plot[n] &gt;= 0:\n    t_drag = t_drag + dt\n    ax = - (ux / u) * k * u**2\n    ay = - g - (uy / u) * k * u**2\n    d_x = d_x + ux * dt + 0.5 * ax * dt**2\n    d_y = d_y + uy * dt + 0.5 * ay * dt**2\n    x_plot.append(d_x)\n    y_plot.append(d_y)\n    ux = ux + ax * dt\n    uy = uy + ay * dt\n    u = math.sqrt(ux**2 + uy**2)\n\n    n = n + 1\n\n\n# Generates the calculated values text\n# Time of flight phrase for drag\nprint(\"Time of flight (drag): \" + str(round(t_drag, 2)) + \" s\")\n\nR_drag = x_plot[n]\n# Range phrase for drag\nprint(\"Range (drag): \" + str(round(R_drag, 2)) + \" m\") \n\nTime of flight (drag): 9.23 s\nRange (drag): 63.24 m\n\n\n\n# Creates the figure\nfig, ax = plt.subplots()\n\n# Sets the parameters of the plot\nax.set_xlabel(\"Displacement in x / m\")\nax.set_ylabel(\"Displacement in y / m\")\nax.set_ylim(0, y_graph)\nax.set_xlim(0, R)\n\n# Components to be plotted\nax.plot(x, y, label=\"No Air Resistance\")\nax.grid()\nax.plot(x_plot, y_plot, label=\"Air Resistance\")\n\nax.legend()"
  },
  {
    "objectID": "posts/cchallenge7.html",
    "href": "posts/cchallenge7.html",
    "title": "BPhO Computational Challenge 2024: Challenge 7: An Examination of the Phenomenon of Local Maxima and Minima on Range Against Time Graphs in Projectile Motion",
    "section": "",
    "text": "Explained below is the solution to the seventh challenge of the BPhO Computational Challenge 2024, where two graphs will be plotted for a range of angles to investigate the idea that the range of a projectile from a launch point plotted against time passes through a local maximum and then a minimum.\nDISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo ."
  },
  {
    "objectID": "posts/cchallenge7.html#calculating-the-range-against-time-curves",
    "href": "posts/cchallenge7.html#calculating-the-range-against-time-curves",
    "title": "BPhO Computational Challenge 2024: Challenge 7: An Examination of the Phenomenon of Local Maxima and Minima on Range Against Time Graphs in Projectile Motion",
    "section": "Calculating the Range Against Time Curves",
    "text": "Calculating the Range Against Time Curves\n\nCalculating r Coordinates\nBelow is the rplot function is used to determine the r coordinates of the range against time graph. For simplicity, (and to meet the specifications of the challenge) initial velocity is set to \\(10 ms^{-1}\\), launch height is set to \\(0 m\\), and acceleration due to gravity is set to \\(10 ms^{-2}\\) (instead of the accepted \\(9.81 ms^{-2}\\)). First, the function converts the angles entered into radians for future use. Then, an empty list for r coordinates is created, and \\(r=0\\) is appended (since the launch height is \\(0 m\\)). Finally, a for loop is used to update the list with each range coordinate using the equation \\(r=\\sqrt{u^2t^2-gt^3u\\sin\\theta+\\frac{1}{4}g^2t^4}\\) in the timestep of \\(0.01s\\) between \\(t=0s\\) and \\(t=2.5s\\) as required in the specification for the challenge.\n\n# Function to plot r\ndef rplot(a):\n    # Paramaters\n    u = 10\n    g = 10\n\n    arad = (a * np.pi) / 180\n\n    # Sin and cos of the angle\n    sintheta = np.sin(arad)\n\n    # Creates array of r and t valuse\n    range = []\n\n    # Appends array with inital conditions\n    range.append(0)\n\n    # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n    for i in np.arange(0, 2.6, 0.01):\n        t = i\n        r = np.sqrt(u**2 * t**2 - g * t**3 * u * sintheta + 0.25 * g**2 * t**4)\n        range.append(r)\n    \n    return range\n\n\n\nCalculating t Coordinates\nSimilar to the rplot function, the tplot function determines the t coordinates of the range against time graph. An empty array of time coordinates is created and \\(t=0\\) is appended to this array. Finally, a for loop is used to find the time coordinates that increment in \\(0.01s\\) intervals between \\(t=0s\\) and \\(t=2.5s\\), and these are appended to the time list.\n\n# Function to plot t\ndef tplot():\n    # Creates array for time valuse\n    time = []\n\n    # Appends array with inital condition\n    time.append(0)\n\n    # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n    for i in np.arange(0, 2.6, 0.01):\n        t = i\n        time.append(t)\n    \n    return time\n\nThe following lines of code call the rplot and tplot functions and pass the six angles corresponding to the six different projectiles to be plotted and the list of t values is calculated.\n\n# Passes parameters of angles \nr1 = rplot(30)\nr2 = rplot(45)\nr3 = rplot(60)\nr4 = rplot(70.5)\nr5 = rplot(78)\nr6 = rplot(85)\n\nt = tplot()"
  },
  {
    "objectID": "posts/cchallenge7.html#calculating-the-stationary-points",
    "href": "posts/cchallenge7.html#calculating-the-stationary-points",
    "title": "BPhO Computational Challenge 2024: Challenge 7: An Examination of the Phenomenon of Local Maxima and Minima on Range Against Time Graphs in Projectile Motion",
    "section": "Calculating the Stationary Points",
    "text": "Calculating the Stationary Points\n\nMinima\nThe function mint() is used to find the t coordinate of each minima. As before, when the angles are passed to the function, they are converted to radians and the preconditions of \\(u=10ms^{-1}\\) and \\(g=10ms^{-2}\\). Then, the equation \\(t=\\frac{3u}{2g}\\sin \\theta+\\sqrt{\\sin^2\\theta-\\frac{8}{9}}\\) is used to find the t coordinate. This is then returned and stored as a variable for future plotting.\n\n# Function to find the t coordinate of the minima\ndef mint(a):\n    u = 10\n    g = 10\n    a = a * (np.pi/180)\n\n    t = ((3 * u) / (2 * g)) * (np.sin(a) + np.sqrt(np.sin(a)**2 - (8/9)))\n\n    return t\n\nThe angles \\(\\theta=78^{\\circ}\\), and \\(\\theta=85^{\\circ}\\) are passed specifically since these two projectiles have a minimum point in the range against time graph.\n\n# Calls function and passses angle parameters\nmint1 = mint(78)\nmint2 = mint(85)\n\nThe second function minr() is used to find the r coordinate of each minima given t and the angle, which are passed. Similarly, the preconditions are set, the angle is set to radians, and the appropriate equation \\(r=\\sqrt{u^2t^2-gt^3u\\sin\\theta+\\frac{1}{4}g^2t^4}\\) is used to find the r coordinate, which is then returned and stored.\n\n# Function to find the r coordinate of the minima\ndef minr(a, t):\n    u = 10\n    g = 10\n    a = a * (np.pi/180)\n\n    r = np.sqrt(u**2 * t**2 - g * t**3 * u * np.sin(a) + 0.25 * g**2 * t**4)\n\n    return r\n\nAgain, the angles \\(\\theta=78^{\\circ}\\), and \\(\\theta=85^{\\circ}\\) are passed specifically since these two projectiles have a minimum point in the range against time graph. The values of t obtained from the previous function are also passed in order to calculate the r coordinate for each minima.\n\n# Calls function and passes angle and t paramaters \nminr1 = minr(78, mint1)\nminr2 = minr(85, mint2)\n\n\n\nMaxima\nThe function maxt() is used to find the t coordinate of each maxima. The initial parameters are set, the angle is converted from degrees to radians and the equation \\(t=\\frac{3u}{2g}\\sin\\theta-\\sqrt{\\sin^2\\theta-\\frac{8}{9}}\\) is used to calculate the t coordinate of the maxima.\n\n# Function to find the t coordinate of the maxima \ndef maxt(a):\n    u = 10\n    g = 10\n    a = a * (np.pi/180)\n\n    t = ((3 * u) / (2 * g)) * (np.sin(a) - np.sqrt(np.sin(a)**2 - (8/9)))\n\n    return t\n\nNow, the angles \\(\\theta=78^{\\circ}\\), and \\(\\theta=85^{\\circ}\\) are passed since the projectiles with these angles of projection have maximum points in their range against time graphs.\n\n# Calls function and passes angle parameters\nmaxt1 = maxt(78)\nmaxt2 = maxt(85)\n\nNext we need to find the r coordinate of each maximum point. Convert from degrees to radians, set initial parameters and calculate r coordinates using the equation \\(r=\\sqrt{u^2t^2-gt^3u\\sin\\theta+\\frac{1}{4}g^2t^4}\\). The same angles are passed along with the t coordinate determined by the previous function.\n\n# Function to find the r coordinate of the maxima\ndef maxr(a, t):\n    u = 10\n    g = 10\n    a = a * (np.pi/180)\n\n    r = np.sqrt(u**2 * t**2 - g * t**3 * u * np.sin(a) + 0.25 * g**2 * t**4)\n\n    return r\n\n# Calls the function and passes t coordinates and angles\nmaxr1 = maxr(78, maxt1)\nmaxr2 = maxr(85, maxt2)\n\n\n\nPoint of Inflection\nstat() finds the t coordinate of the point of inflection by using the equation \\(t=\\frac{u}{g}\\sqrt{2}.\\)\n\n# Finds t coordinate of the point of inflection\ndef stat():\n    u = 10\n    g = 10\n\n    t = (u / g) * np.sqrt(2)\n\n    return t \n\nstat1 = stat()\n\nBy using the equation \\(r=\\sqrt{u^2t^2-gt^3u\\sin\\theta+\\frac{1}{4}g^2t^4}\\), and by passing the t coordinate of the point of inflection and the angle \\(\\theta=70.5^{circ}\\) the r coordinate of the point of inflection is obtained.\n\n# Finds r coordinate of the point of inflection\ndef star(a, t):\n    u = 10\n    g = 10\n    a = a * (np.pi / 180)\n\n    r = np.sqrt(u**2 * t**2 - g * t**3 * u * np.sin(a) + 0.25 * g**2 * t**4)\n\n    return r    \n\nstar1 = star(70.5, stat1)"
  },
  {
    "objectID": "posts/cchallenge7.html#plotting-range-against-time",
    "href": "posts/cchallenge7.html#plotting-range-against-time",
    "title": "BPhO Computational Challenge 2024: Challenge 7: An Examination of the Phenomenon of Local Maxima and Minima on Range Against Time Graphs in Projectile Motion",
    "section": "Plotting Range Against Time",
    "text": "Plotting Range Against Time\nCreates the first figure for the range against time graph.\n\nfig1, ax = plt.subplots()\n\n\n\n\n\n\n\n\nPlots the range against time graphs for each angle.\n\n# Components to be plotted\nax.plot(t, r1, label=\"θ = 30°\")\nax.plot(t, r2, label=\"θ = 45°\")\nax.plot(t, r3, label=\"θ = 60°\")\nax.plot(t, r4, label=\"θ = 70.5°\")\nax.plot(t, r5, label=\"θ = 78°\")\nax.plot(t, r6, label=\"θ = 85°\")\n\nPlots the minima, maxima and point of inflection using the scatter function.\n\n# Plots minima\nax.scatter(mint1, minr1, color=\"black\", marker=\"x\")\nax.scatter(mint2, minr2, color=\"black\", marker=\"x\")\n\n# Plots maxima\nax.scatter(maxt1, maxr1, color=\"red\", marker=\"x\")\nax.scatter(maxt2, maxr2, color=\"red\", marker=\"x\")\n\n# Plots point of inflection\nax.scatter(stat1, star1, color=\"blue\", marker=\"x\")\n\nSets the parameters of the plot. The labels for the x and y axes are set and importantly the limits for t and r are set to match the specification of the challenge.\n\n# Sets the parameters of the plot\nax.set_xlabel(\"Range, r / m\")\nax.set_ylabel(\"Time, t / s\")\nax.set_ylim(0, 30)\nax.set_xlim(0, 2.5)\nax.grid()\nax.legend()"
  },
  {
    "objectID": "posts/cchallenge7.html#calculating-x-and-y-coordinates",
    "href": "posts/cchallenge7.html#calculating-x-and-y-coordinates",
    "title": "BPhO Computational Challenge 2024: Challenge 7: An Examination of the Phenomenon of Local Maxima and Minima on Range Against Time Graphs in Projectile Motion",
    "section": "Calculating x and y Coordinates",
    "text": "Calculating x and y Coordinates\n\nCalculating the x Coordinates\nThe function xplot() plots the x coordinates of the trajectories for graph of the trajectories of each projectile. The angle for each curve to be plotted is passed to the function. The preconditions of velocity and acceleration due to gravity are set as before and the angle is converted into radians. The velocity is then resolved into its horizontal component using the equation \\(u_x=u\\cos\\theta\\). An empty array of x coordinates is created and a for loop is used to append each x point to the list with an interval of 0.01s using the equation \\(x=u_xt\\). This list of x coordinates is then returned for plotting.\n\ndef xplot(a):\n    u = 10\n    g = 10\n\n    arad = (a * np.pi) / 180\n\n    ux = u * np.cos(arad)\n\n    # Creates an empty arrary for the x and y coordinates of the trajectory\n    x = []\n\n    # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n    for i in np.arange(0, 3, 0.01):\n        t = i\n        x.append(ux * t)\n\n    return x\n\nThis section of code passes each angle to the function xplot().\n\n# Passes parameters of angles \nx1 = xplot(30)\nx2 = xplot(45)\nx3 = xplot(60)\nx4 = xplot(70.5)\nx5 = xplot(78)\nx6 = xplot(85)\n\n\n\nCalculating the y Coordinates\nThe yplot() function plots the y coordinates of the trajectories. The angle for each curve to be plotted is passed to the function. The preconditions are set and the angle is converted into radians. The velocity is then resolved into its vertical component using the equation \\(u_y=u\\sin\\theta\\). An empty list of y coordinates is created and a for loop is used to append each y point to the array with an interval of 0.01s using the equation \\(y=h+u_yt-\\frac{1}{2}gt^2\\). This list of y coordinates is then returned.\n\ndef yplot(a):\n    u = 10\n    g = 10\n    h = 0\n\n    arad = (a * np.pi) / 180\n\n    uy = u * np.sin(arad)\n\n    # Creates an empty arrary for the x and y coordinates of the trajectory\n    y = []\n\n    # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n    for i in np.arange(0, 3, 0.01):\n        t = i\n        y.append(h + (uy * t) - (0.5 * g * t**2))   \n\n    return y    \n\nThis section of code passes each angle to the function yplot().\n\n# Passes parameters of angles \ny1 = yplot(30)\ny2 = yplot(45)\ny3 = yplot(60)\ny4 = yplot(70.5)\ny5 = yplot(78)\ny6 = yplot(85)"
  },
  {
    "objectID": "posts/cchallenge7.html#calculating-the-stationary-points-1",
    "href": "posts/cchallenge7.html#calculating-the-stationary-points-1",
    "title": "BPhO Computational Challenge 2024: Challenge 7: An Examination of the Phenomenon of Local Maxima and Minima on Range Against Time Graphs in Projectile Motion",
    "section": "Calculating the Stationary Points",
    "text": "Calculating the Stationary Points\nThe stax() function finds the x coordinate of each stationary point given the angle and time, which are passed as parameters. The preconditions are determined and the angle is converted into radians. Velocity is resolved into its horizontal component using the equation \\(u_x=u\\cos\\theta\\) and then the equation \\(x=u_xt\\) is used to find the x coordinate as before, which is returned and stored for plotting.\n\n# Function to find x coordinate of each stationary point\ndef stax(a, t):\n    u = 10\n    g = 10\n    a = a * (np.pi / 180)\n\n    ux = u * np.cos(a)\n\n    x = ux * t\n\n    return x\n\nThe below code passes the angles and t coordinates to the function stax().\n\n# Calls function and passes paramters angle and t\nstax1 = stax(78, mint1)\nstax2 = stax(85, mint2)\nstax3 = stax(78, maxt1)\nstax4 = stax(85, maxt2)\nstax5 = stax(70.5, stat1)\n\nThe stay() function finds the y coordinate of each stationary point given the angle and time, which are passed. The preconditions are set and the angle is converted into radians. Velocity is resolved into its vertical component and then the equation is used to find the y coordinate with the equations used previously (\\(u_y=u\\sin\\theta\\) and \\(y=u_yt-\\frac{1}{2}gt^2\\) respectively).\n\n# Function to find the y coordinate of each stationary point\ndef stay(a, t):\n    u = 10\n    g = 10\n    a = a * (np.pi / 180)\n\n    uy = u * np.sin(a)\n\n    y = uy * t - 0.5 * g * t**2\n\n    return y\n\nThe below code passes the angles and t coordinates to the function stay().\n\n# Calls function and passes paramaters angle and t\nstay1 = stay(78, mint1)\nstay2 = stay(85, mint2)\nstay3 = stay(78, maxt1)\nstay4 = stay(85, maxt2)\nstay5 = stay(70.5, stat1)"
  },
  {
    "objectID": "posts/cchallenge7.html#plotting-the-position-graph",
    "href": "posts/cchallenge7.html#plotting-the-position-graph",
    "title": "BPhO Computational Challenge 2024: Challenge 7: An Examination of the Phenomenon of Local Maxima and Minima on Range Against Time Graphs in Projectile Motion",
    "section": "Plotting the Position Graph",
    "text": "Plotting the Position Graph\nA second figure is created to display the graph of the trajectories of each projectile.\n\n# Components to be plotted\nfig2, ax = plt.subplots()\n\n\n\n\n\n\n\n\nThe trajectories of each projectile corresponding to the different angles of projection are plotted.\n\nax.plot(x1, y1, label=\"θ = 30°\")\nax.plot(x2, y2, label=\"θ = 45°\")\nax.plot(x3, y3, label=\"θ = 60°\")\nax.plot(x4, y4, label=\"θ = 70.5°\")\nax.plot(x5, y5, label=\"θ = 78°\")\nax.plot(x6, y6, label=\"θ = 85°\")\n\nThe scatter function is used to plot the maxima, minima and points of inflection from the previous graph.\n\n# Plots stationary points\nax.scatter(stax1, stay1, color=\"black\", marker=\"x\")\nax.scatter(stax2, stay2, color=\"black\", marker=\"x\")\nax.scatter(stax3, stay3, color=\"red\", marker=\"x\")\nax.scatter(stax4, stay4, color=\"red\", marker=\"x\")\nax.scatter(stax5, stay5, color=\"blue\", marker=\"x\")\n\nThe parameters of the plot are set, the axes are given appropriate labels, the limits of the graph are set to match the specification, and the grid and legend are created.\n\n# Sets the parameters of the plot\nax.set_xlabel(\"Displacement in x / m\")\nax.set_ylabel(\"Displacement in y / m\")\nax.set_ylim(-5, 5)\nax.set_xlim(0, 15)\nax.grid()\nax.legend()\n\nFinally, the graph is displayed.\n\nplt.show()"
  },
  {
    "objectID": "posts/cchallenge5.html",
    "href": "posts/cchallenge5.html",
    "title": "BPhO Computational Challenge 2024: Challenge 5: Implementing the Bounding Parabola to the Projectile Model",
    "section": "",
    "text": "DISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo .\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\n\n\nX = 1000\nY = 300\nu = 150\ng = 9.81\n\n\nminu = np.sqrt(g) * (np.sqrt(Y + np.sqrt(X**2 + Y**2)))\nmintheta = math.atan((Y + np.sqrt(X**2 + Y**2)) / X)\nminux = minu * np.cos(mintheta)\nminuy = minu * np.sin(mintheta)\nmint = 2 * (minuy / g)\n\nx = []\ny = []\n\nfor i in np.arange(0, mint, 0.01):\n    t = i\n    x.append(minux * t)\n    T = t**2\n    y.append((minuy * t) - (0.5 * g * T))\n    \na = (g / (2 * u**2)) * X**2\nb =  -X\nc = Y + ((g * X**2)/(2 * u**2))\nlow_theta = math.atan((- b - np.sqrt(b**2 - (4 * a * c)))/(2 * a))\nhigh_theta = math.atan((- b + np.sqrt(b**2 - (4 * a * c)))/(2 * a))\n\nlow_ux = u * np.cos(low_theta)\nlow_uy = u * np.sin(low_theta)\nlow_tflight = 2 * (low_uy / g)\n\nlow_x = []\nlow_y = []\n\nfor low_i in np.arange(0, low_tflight, 0.01):\n    low_t = low_i\n    low_x.append(low_ux * low_t)\n    low_T = low_t**2\n    low_y.append((low_uy * low_t) - (0.5 * g * low_T))\n    \nhigh_ux = u * np.cos(high_theta)\nhigh_uy = u * np.sin(high_theta)\nhigh_tflight = 2 * (high_uy / g)\n\nhigh_x = []\nhigh_y = []\n\nfor high_i in np.arange(0, high_tflight, 0.01):\n    high_t = high_i\n    high_x.append(high_ux * high_t)\n    high_T = high_t**2\n    high_y.append((high_uy * high_t) - (0.5 * g * high_T))\n\nu2 = u * u\ntgh = 2 * g\ntghu2 = (tgh) / (u2)\narc = (1 / np.sqrt((2 + tghu2)))\n\nthetamax = np.arcsin(arc)\n\ncosthetamax = np.cos(thetamax)\nsinthetamax = np.sin(thetamax)\n\nmax_ux = u * costhetamax\nmax_uy = u * sinthetamax\nmax_tflight = 2 * (max_uy / g)\n\n# Creates an empty arrary for the x and y coordinates of the trajectory\nmax_x = []\nmax_y = []\n\n# Plots the parabolic path of the projectile with a timestep of 0.01s and an interval of 10s\nfor max_i in np.arange(0, max_tflight, 0.01):\n    max_t = max_i\n    max_x.append(max_ux * max_t)\n    max_T = max_t * max_t\n    max_y.append((max_uy * max_t) - (0.5 * g * max_T))\n    \nmax_range = max_tflight * max_ux\n    \nbounding_a = - (g / (2 * u**2))\nbounding_c = (u**2) / (2 * g)\nbounding_x = np.linspace(0, max_range, 100)\nbounding_y = bounding_a * bounding_x**2 + bounding_c\n\nplt.plot(x, y, label=\"Minimum u\", zorder=1)\nplt.plot(low_x, low_y, label=\"Low Ball\", zorder=2)\nplt.plot(high_x, high_y, label=\"High Ball\", zorder=3)\nplt.plot(bounding_x, bounding_y, label=\"Bounding Parabola\", zorder=4)\nplt.plot(max_x, max_y, label=\"Maximum Range\", zorder=5)\nplt.scatter(X, Y, color=\"red\", marker=\"x\", zorder=6, label=(X,Y))\n\nplt.xlabel(\"Displacement in x / m\")\nplt.ylabel(\"Displacement in y / m\")\nplt.ylim(0)\nplt.xlim(0, max_range)\nplt.grid()\nplt.legend(loc=\"upper right\")\n\n\nplt.show()"
  },
  {
    "objectID": "posts/cchallenge3.html",
    "href": "posts/cchallenge3.html",
    "title": "BPhO Computational Challenge 2024: Challenge 3: Calculating the trajectories of the Low Ball, High Ball and Minimum Initial Velocity to Hit (X, Y)",
    "section": "",
    "text": "Introduction\nDetailed in this blog post is the solution to the third challenge of the BPhO Computational Challenge 2024. The objective is to calculate the trajectories of three projectiles which are launched from (0, 0) and pass through fixed point (X, Y). One of these projectiles is the minimum launch velocity needed for the projectile to hit the chosen point, and the second and third are “low and high ball” trajectories, the highest and lowest possible angles the projectile can be launched at and still collide with the target coordinates based on the entered initial velocity.\nDISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo .\n\n\nSetting up the Problem\nFirst, the fundamental libraries are imported. Matplotlib for plotting, numpy for mathematical and trigonometric functions, math for trigonomatric functions (specifically arctan) and figure is imported from matplotlib to use the axes functions.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\n\nNext, the conditions / parameters of the model are set. In the final GUI application submitted for the competition, these would be inputted using text input boxes. \\(g\\) would be set using a combobox containing popular celestial objects, such as the planets in our solar system, or using a text box to enter a custom value.\n\\(Y\\) is the y coordinate that is hit by the projectile and \\(X\\) is the x coordinate.\nFor the purpose of this demonstration of the algorithm, I have used the below values:\n\nX = 1000\nY = 300\nu = 150\ng = 9.81\n\nThe problem must be decomposed into three separate problems. The first problem is the minimum velocity projectile. There are equations which can be used to calculate the minimum velocity and the corresponding angle of projection for the model. The second and third problems consist of the low and high ball trajectories. These can also be computed using equations.\n\n\nMinimum Launch Velocity\nThe minimum launch velocity must be calculated. This is achieved using the equation \\(u_{min}=\\sqrt{g}\\sqrt{Y + \\sqrt{X^2 + Y^2}}\\).\nNow, the corresponding angle of projection must be calculated using \\(\\theta_{min}=\\tan^{-1}(\\frac{Y+\\sqrt{X^2+Y^2}}{X})\\).\nThen, the velocity of the projectile is resolved into its horizontal and vertial components using the equations \\(u_x^{min}=u_{min}\\cos(\\theta_{min})\\) and \\(u_y^{min}=u_{min}\\sin(\\theta_{min})\\).\nFinally, the time of flight is calculated with \\(T_{min}=\\frac{X}{u_x^{min}}\\).\n\nminu = np.sqrt(g) * (np.sqrt(Y + np.sqrt(X**2 + Y**2)))\nmintheta = math.atan((Y + np.sqrt(X**2 + Y**2)) / X)\nminux = minu * np.cos(mintheta)\nminuy = minu * np.sin(mintheta)\nmint = X / minux\n\nAn empty array of x and y coordinates for the minimum velocity trajectory are created. These will be appended to in the for loop. A timestep of 0.01s is used to calculate the position of the projectile between the instant the projectile is launched and the time of flight. The equations \\(x_{min}=u_x^{min}t\\) and \\(y_{min}=u_y^{min}t-\\frac{1}{2}gt^2\\) are used to update the x and y coordinates of the projectile between each timestep.\n\nx = []\ny = []\n\nfor i in np.arange(0, mint, 0.01):\n    t = i\n    x.append(minux * t)\n    T = t**2\n    y.append((minuy * t) - (0.5 * g * T))\n\n\n\nLow and High Ball Trajectories\nThe angle of projection for the low and high ball trajectories is determined using the following equations: \\(\\theta_{\\pm}=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\\), where \\(a=\\frac{g}{2u^2}X^2\\), \\(b=-X\\) and \\(c=Y+\\frac{gX^2}{2u^2}\\).\n\na = (g / (2 * u**2)) * X**2\nb =  -X\nc = Y + ((g * X**2)/(2 * u**2))\nlow_theta = math.atan((- b - np.sqrt(b**2 - (4 * a * c)))/(2 * a))\nhigh_theta = math.atan((- b + np.sqrt(b**2 - (4 * a * c)))/(2 * a))\n\nThe velocity is resolved into its horizontal and vertical components and the time of flight for the low ball trajectory is calculated using the equations \\(u_x^{-}=u\\cos(\\theta_{-})\\), \\(u_y^{-}=u\\sin(\\theta_{-})\\) and \\(T_{-}=\\frac{X}{u_x^{-}}\\) respectively.\n\nlow_ux = u * np.cos(low_theta)\nlow_uy = u * np.sin(low_theta)\nlow_tflight = X / low_ux\n\nAgain, a for loop is used to calculate the x and y coordiantes of the projectile with a timestep of 0.01s between the instant the projectile is launched and the time of flight. Empty arrays of x and y coordinates are created and appended to using the equations: \\(x_{-}=u_x^{-}t\\) for x coordiantes and \\(y_{-}=u_y^{-}t-\\frac{1}{2}gt^2\\) for y coordinates.\n\nlow_x = []\nlow_y = []\n\nfor low_i in np.arange(0, low_tflight, 0.01):\n    low_t = low_i\n    low_x.append(low_ux * low_t)\n    low_y.append((low_uy * low_t) - (0.5 * g * low_t**2))\n\nThis process is then repeated for the high ball trajectory.\n\nhigh_ux = u * np.cos(high_theta)\nhigh_uy = u * np.sin(high_theta)\nhigh_tflight = X / high_ux\n\nhigh_x = []\nhigh_y = []\n\nfor high_i in np.arange(0, high_tflight, 0.01):\n    high_t = high_i\n    high_x.append(high_ux * high_t)\n    high_y.append((high_uy * high_t) - (0.5 * g * high_t**2))\n\n\n\nPlotting the Trajectories\nFirst, a figure of subplots is created to use the ax functions.\nThe three trajectories are then plotted, along with the marker showing the user’s chosen coordinate.\nFinally, the parametrs of the plot are set, including labels for the axes, limits for the axes and labels for each of the trajectories.\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, label=\"Minimum u\")\nax.plot(low_x, low_y, label=\"Low Ball\")\nax.plot(high_x, high_y, label=\"High Ball\")\nax.scatter(X, Y, marker=\"x\", color=\"red\")\n\nax.set_xlabel(\"Displacement in x / m\")\nax.set_ylabel(\"Displacement in y / m\")\nax.set_ylim(0)\nax.set_xlim(0, X)\n\nax.legend()"
  },
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "Coding Projects",
    "section": "",
    "text": "A Comparitive Analysis of Computational Methods Performing Numerical Integration: Simpson’s Rule and Trapezium Rule\n\n\n\n\n\n\nPython\n\n\nNumerical Methods\n\n\nNumeric Integration\n\n\n\nBy integrating a polynomial and trigonometric function using both Simpson’s Rule and Trapezium Rule and measuring the time taken for each to be calculated, I aim to compare and analyse the two methods.\n\n\n\n\n\nJun 24, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nA Numerical Method to Calculate the Derivative using the Central Difference Method and a Small Step, ϵ\n\n\n\n\n\n\nPython\n\n\nNumerical Methods\n\n\nNumeric Differentiation\n\n\n\nAn implementation of calculating the numerical derivative using the central difference method and a small step, ϵ, in Python, for the purpose of plotting and use in the gradient descent algorithm.\n\n\n\n\n\nJul 28, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 1 & 2: Creating a Simple Analytical Drag-Free Projectile Model\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the first two challenges of the BPhO Computational Challenge 2024, an analytical projectile model which creates a trajectory and outputs time of flight, range and the apogee.\n\n\n\n\n\nMar 7, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 3: Calculating the trajectories of the Low Ball, High Ball and Minimum Initial Velocity to Hit (X, Y)\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the third challenge of the BPhO Computational Challenge 2024, calculating the trajectory of three projectiles, the lowest and highest angles to hit coordinate (X, Y) based on an inputted initial velocity and the minimum initial velocity needed to hit the given coordinate.\n\n\n\n\n\nMar 24, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 4: Maximising the Range of a Projectile Using a Given Initial Velocity\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the fourth challenge of the BPhO Computational Challenge 2024, comparing a custom projectile with a projectile which maximises horizontal range using the same initial velocity.\n\n\n\n\n\nApr 9, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 5: Implementing the Bounding Parabola to the Projectile Model\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the fifth challenge of the BPhO Computational Challenge 2024, implementing the bounding parabola, the region of possible points the projectile can reach based on a given initial velocity.\n\n\n\n\n\nApr 11, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 6: Calculating the Distance Travelled by a Drag-Free Projectile using Integration\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the sixth challenge of the BPhO Computational Challenge 2024, calculating the distance travelled by the projectile, the length of the inverted parabolic arc, using integration.\n\n\n\n\n\nMay 5, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 7: An Examination of the Phenomenon of Local Maxima and Minima on Range Against Time Graphs in Projectile Motion\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the seventh challenge of the BPhO Computational Challenge 2024, investigating the idea that the range of a projectile from a launch point plotted against time passes through a local maximum and then a minimum.\n\n\n\n\n\nMay 19, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 8: Creating a Bouncing Projectile Model Using Verlet Integration\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the eighth challenges of the BPhO Computational Challenge 2024, calculating the trajectory of a bouncing ball using Verlet integration.\n\n\n\n\n\nMay 26, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 9: Creating a Projectile Model Incorporating Air Resistance Using Verlet Integration\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the ninth challenge of the BPhO Computational Challenge 2024, creating a projectile model incoporating air resistance using Verlet integration for comparison with a drag-free model.\n\n\n\n\n\nMay 9, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Extension: Creating a Projectile Model Incorporating both Air Resistance and Varying Air Density with Height Using Verlet Integration\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the extension of the BPhO Computational Challenge 2024, incorporating varying air density with height using Verlet integration for comparsion with the models with and without air resistance.\n\n\n\n\n\nJun 10, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nComputing the Greatest Common Divisior (GCD) Using the Euclidean Algorithm\n\n\n\n\n\n\nPython\n\n\nNumber Theory\n\n\n\nImplementing the Euclidean Algorithm to find the Greatest Common Divisor (GCD) of two positive integers.\n\n\n\n\n\nAug 29, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nGenerating the nth Prime Number\n\n\n\n\n\n\nPython\n\n\nPrime Numbers\n\n\nProject Euler\n\n\n\nPython program which calculates an inputted nth prime number by dividing each consecutive number by previous prime numbers.\n\n\n\n\n\nAug 14, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nMonte Carlo Simulation: Estimating π\n\n\n\n\n\n\nPython\n\n\nMonte Carlo\n\n\nSimulation\n\n\nStatistics\n\n\nNumerical Methods\n\n\n\nEstimating π using the famous Monte Carlo Simulation.\n\n\n\n\n\nSep 18, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nOptimisation: The Gradient Descent Algorithm for Maching Learning\n\n\n\n\n\n\nPython\n\n\nOptimisation\n\n\nMachine Learning\n\n\n\nPython program which uses the gradient descent algorithm to calculate minimum points for a given function. Used for optimisation in machine learning.\n\n\n\n\n\nAug 13, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nRoot Finding using the Newton-Raphson Method\n\n\n\n\n\n\nPython\n\n\nNumerical Methods\n\n\nIterative Root Finding\n\n\n\nThe Newton-Raphson Method: A powerful numerical technique to efficiently find the roots of non-linear functions iteratively.\n\n\n\n\n\nSep 12, 2024\n\n\nMark Watson\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html#python-experience",
    "href": "about.html#python-experience",
    "title": "Mark Watson",
    "section": "Python Experience",
    "text": "Python Experience\nI have about 5 years of experience in Python, creating various projects and entering in competitions with Python, some of which are shown in the coding projects tab. Most notably, I achieved a Gold Award in the BPhO Computational Challenge 2024."
  },
  {
    "objectID": "about.html#bpho-computational-challenge-2024",
    "href": "about.html#bpho-computational-challenge-2024",
    "title": "Mark Watson",
    "section": "BPhO Computational Challenge 2024",
    "text": "BPhO Computational Challenge 2024\nThe aim of the challenge is to solve classical Physics problems computationally. For the 2024 rendition of the challenge, we created a GUI application consisting of 9 projectile models, including a projectile model considering both air restistance and varying air density with height. During the challenge, I also learnt how to write scientific papers using LaTex, one of the extensions of the competition. Click here: BPhO Computational Challenge Code & Explanations to see our solutions to the challenge."
  },
  {
    "objectID": "about.html#machine-learning",
    "href": "about.html#machine-learning",
    "title": "Mark Watson",
    "section": "Machine Learning",
    "text": "Machine Learning\nMost of my experience in machine learning is in the applications of machine learning, such as applying machine learning algorithms to galaxy classification, see my EPQ. Some of my projects have involved rudimentary machine learning algorithms, for instance, I explored how the gradient descent algorithm and optimisation could be used"
  },
  {
    "objectID": "about.html#epq",
    "href": "about.html#epq",
    "title": "Mark Watson",
    "section": "EPQ",
    "text": "EPQ"
  },
  {
    "objectID": "about.html#web-development",
    "href": "about.html#web-development",
    "title": "Mark Watson",
    "section": "Web Development",
    "text": "Web Development\nThroughout the course of developing this and other websites, I have gained a lot of experience in HTML and CSS. While developing this website, I gained many valuable skills and learnt a lot, such as how Git works, using version control, developing websites and blogs using Quarto, creating mathematical expressions with LaTex and using GitHub and GitHub pages."
  },
  {
    "objectID": "about.html#astrophotography",
    "href": "about.html#astrophotography",
    "title": "Mark Watson",
    "section": "Astrophotography",
    "text": "Astrophotography\nIn my free time, I enjoy capturing images of distant deep sky objects using astrophotography."
  },
  {
    "objectID": "about.html#chess",
    "href": "about.html#chess",
    "title": "Mark Watson",
    "section": "Chess",
    "text": "Chess\nI am also a passionate chess player. I have several high tournament finishes in my category, including a bronze at the prestigious Doncaster Chess Congress and a silver at the Darnall & Handsworth Rapidplay September 2023. I have also regularly represented my local town, Rotherham, in the second division of the Sheffield & District Chess Association for the past 3 years. I founded and captained my school’s Chess Club for the past 5 years and volunteered my time to tutor the younger students."
  },
  {
    "objectID": "about.html#languages",
    "href": "about.html#languages",
    "title": "Mark Watson",
    "section": "Languages",
    "text": "Languages\nFinally, I love learning languages. I am fluent in Polish and have been learning Russian and German for the past few years."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Welcome to my portfolio of programming projects and competition submissions\n\n\nFeatured Projects\nHere are some of my favourite projects ranging from numerical methods to optimisation for machine learning. For all my projects check out the Coding Projects tab.\n\n\n\n\n\n\n\nRoot Finding using the Newton-Raphson Method\n\n\n\n\n\n\n\n\n\nOptimisation: The Gradient Descent Algorithm\n\n\n\n\n\n\n\n\n\nMonte Carlo Simulation: Estimating π\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024:\n\nVideo Submission\n\n\nCode and Explanations\n\n\n\n\n\n\n\nChallenge 1 & 2: Drag-Free Projectile Model\n\n\n\n\n\n\n\n\n\nChallenge 3: Minimum u, Low Ball and High Ball\n\n\n\n\n\n\n\n\n\nChallenge 4: Maximising Range\n\n\n\n\n\n\n\n\n\nChallenge 5: The Bounding Parabola\n\n\n\n\n\n\n\n\n\nChallenge 6: Calculating Distance Travelled\n\n\n\n\n\n\n\n\n\nChallenge 7: Local Maxima and Minima\n\n\n\n\n\n\n\n\n\nChallenge 8: Bouncing Ball Model\n\n\n\n\n\n\n\n\n\nChallenge 9: Incorporating Air Resistance\n\n\n\n\n\n\n\n\n\nExtension: Incorporating Varying Air Density"
  },
  {
    "objectID": "posts/cchallenge1.html",
    "href": "posts/cchallenge1.html",
    "title": "BPhO Computational Challenge 2024: Challenge 1 & 2: Creating a Simple Analytical Drag-Free Projectile Model",
    "section": "",
    "text": "Introduction\nThe below code is my implementation of the first and second challenge of the BPhO Computational Challenge 2024. The objective was to create an exact analytical model of projectile motion without air resistance, and calculate its range, time of flight and apogee.\nDISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo .\n\n\nSetting up the Problem\nFirst, the plotting library matplotlib is imported, which will be used to plot the trajectory of the projectile. Also, numpy will be imported for its trigonometric and mathematical functions.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nThe program takes inputs \\(\\theta\\), \\(u\\), \\(g\\) and \\(h\\). The commented out sections of code show how the user would be asked to input these. In this example, I have used \\(\\theta=37\\), \\(u=23.31\\), \\(g=9.81\\) and \\(h = 12.32\\). The angle entered in degrees is converted into radians for future use.\n\n# Enables the user to enter conditions for the trajectory\n# angle = float(input(\"Enter the angle of projection in degrees: \"))\nangle = 37\ntheta = (angle * np.pi) / 180\n\n# u = float(input(\"Enter the intitial velocity of the projectile: \"))\nu = 23.31\n\ng = 9.81\n\n# h = float(input(\"Enter the height above the ground of the projectile: \"))\nh = 12.32\n\nThis section of code prevents the user inputting an invalid height less than 0.\n\nif h &lt; 0:\n    print(\"ERROR Height must be greater than 0\")\n    exit()\n\nThe variables costheta and sintheta are created since they are used frequently in the program. Then, the velocity is resolved into horizontal and vertical components using the equations \\(u_x=u\\cos\\theta\\) and \\(u_y=u\\sin\\theta\\).\n\n# Resloves forces into horizontal and vertical component\ncostheta = np.cos(theta)\nsintheta = np.sin(theta)\n\nux = u * costheta\nuy = u * sintheta\n\n\n\nCalculating the Range\nNow, the program calculates the range of the projectile and outputs the calculated value. This is achieved using the equation \\(R=\\frac{u^2}{g}(\\sin\\theta\\cos\\theta+\\cos\\theta\\sqrt{\\sin^2\\theta+\\frac{2gh}{u^2}})\\). The x_graph variable is used to determine the highest x coordinate displayed on the plot, which is determined from the range. This is purely aesthetic.\n\nR = (u**2 / g) * (sintheta * costheta + costheta * np.sqrt(sintheta**2 + (2 * g * h)/ (u**2)))\nprint(\"The range is\", round(R, 2), \"m\")\nx_graph = R + R * 0.1\n\nThe range is 66.36 m\n\n\n\n\nCalculating the Time of Flight\nThe time of flight is then calculated using the general time equation and the range. The equation for the time of flight at a given x coordinate is \\(t=\\frac{x}{u_x}\\) so the time of flight across the range is \\(T=\\frac{R}{u_x}\\). The calculated value is then output along with a phrase.\n\n#Time of flight calculation\ntflight = R / ux\nprint(\"The time of flight is\", round(tflight, 2), \"s\")  \n\nThe time of flight is 3.56 s\n\n\n\n\nComputing the Trajectory of the Drag-Free Projectile\nAn empty list of x and y coordinates are created. These will then be appended to when the position of the projectile is updated.\nA for loop with a timestep of 0.01s, updates the position of the projectile between 0s and the time of flight every 0.01s. The equations \\(x=u_xt\\) and \\(y=h+u_yt-\\frac{1}{2}gt^2\\) are used to update the x and y coordinates respectively at a given time, \\(t\\).\n\n# Creates an empty arrary for the x and y coordinates of the trajectory\nx = []\ny = []\n\n# Plots the parabolic path of the projectile with a timestep of 0.01s and an interval of 10s\nfor i in np.arange(0, tflight, 0.01):\n    t = i\n    x.append(ux * t)\n    T = t * t\n    y.append(h + (uy * t) - (0.5 * g * T))\n    t += 1\n\n\n\nCalculating the Apogee\nThen, the x and y coordinates of the apogee are calculated using the equations \\(x_a=\\frac{u^2}{g}\\sin\\theta\\cos\\theta\\) and \\(y_a=h+\\frac{u^2}{2g}\\sin^2\\theta\\). The y_graph variable is used to determine the y limit of the graph, the highest y coordinate displayed. Finally, a phrase is created which outputs the coordinates of the apogee.\n\n# Apogee calculation\napx = u**2 / g * sintheta * costheta\n\napy = h + u**2 / (2 * g) * sintheta**2\ny_graph = apy + apy * 0.1\n\nprint(\"The apogee is at (\", round(apx, 2), \",\", round(apy, 2), \")\")\n\nThe apogee is at ( 26.62 , 22.35 )\n\n\n\n\nPlotting the Trajectory\nFor the last portion of code, the graph is plotted along with the coordinates of the apogee. The parameters of the graph are then set, including labels and limits, and then the graph is plotted.\n\nplt.plot(x, y)\nplt.scatter(apx, apy, marker=\"x\", color=\"red\")\n\nplt.xlabel(\"Displacement in x / m\")\nplt.ylabel(\"Displacement in y / m\")\nplt.ylim(0, y_graph)\nplt.xlim(0, x_graph)\nplt.show()"
  },
  {
    "objectID": "posts/cchallenge4.html",
    "href": "posts/cchallenge4.html",
    "title": "BPhO Computational Challenge 2024: Challenge 4: Maximising the Range of a Projectile Using a Given Initial Velocity",
    "section": "",
    "text": "DISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo .\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\n\n\n# Setting Initial Conditions\ng = 9.81\nu = 15\nangle = 30 \nh = 10\n\n\n# Converts angle entered in degress to radians\ntheta = (angle * np.pi) / 180\n\n\n# Resloves forces into horizontal and vertical component\ncostheta = math.cos(theta)\nsintheta = math.sin(theta)\n\nux = u * costheta\nuy = u * sintheta\n\n\n# Calculates the range and time of flight of the projectile\nR = (u**2 / g) * (sintheta*costheta+costheta*math.sqrt(sintheta**2 + ((2 * g * h) / (u**2))))\n\n# Range phrase\nrangeph = \"R=\" + str(round(R, 2)) + \" m\"    \nprint(rangeph)\n\nR=30.97 m\n\n\n\n# Calculates time of flight\ntflight = R / (u * costheta)\n\n# Generates the calculated values text\n# Time of flight phrase\ntflightph = \"T=\" + str(round(tflight, 2)) + \" s\"\nprint(tflightph)\n\nT=2.38 s\n\n\n\n# Creates an empty arrary for the x and y coordinates of the trajectory\nx = []\ny = []\n\n# Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\nfor i in np.arange(0, tflight, 0.01):\n    t = i\n    x.append(ux * t)\n    T = t * t\n    y.append(h + (uy * t) - (0.5 * g * T))      \n\n\n# Apogee calculation\napy = (0 - (uy*uy)) / (2 * g * -1) + h\ntflight0 = 2 * uy / g\napx = (ux * tflight0) / 2\n\n\n# Calculations for the trajectory that maximises range\nu2 = u * u\ntgh = 2 * g * h\ntghu2 = (tgh) / (u2)\narc = (1 / (math.sqrt(2 + tghu2)))\n\nthetamax = np.arcsin(arc)\n\nmax_ux = u * math.cos(thetamax)\nmax_uy = u * math.sin(thetamax)\n\n# Creates an empty arrary for the x and y coordinates of the trajectory\nmax_x = []\nmax_y = []\n\n# Calculates the range and time of flight of the projectile\nmax_R = (u**2 / g) * math.sqrt(1 + (2 * g * h/ u**2))\nmax_tflight = max_R / max_ux\n\n# Plots the parabolic path of the projectile with a timestep of 0.01s and an interval of 10s\nfor max_i in np.arange(0, max_tflight, 0.01):\n    max_t = max_i\n    max_x.append(max_ux * max_t)\n    max_T = max_t * max_t\n    max_y.append(h + (max_uy * max_t) - (0.5 * g * max_T))\n    \n# Apogee calculation\nmax_apy = (0 - (max_uy*max_uy)) / (2 * g * -1) + h\n\n\n# Compares the y values of the two apogees\ndef compapy(apy, max_apy):\n    if apy &gt; max_apy:\n        return apy\n    else:\n        return max_apy\ny_graph = compapy(apy, max_apy) * 1.1 \n\n\n# Generates the calculated values text\n# Time of flight phrase\ntflightph = \"Tₘₐₓ=\" + str(round(max_tflight, 2)) + \" s\"\nprint(tflightph)\n\nTₘₐₓ=2.59 s\n\n\n\n# Range phrase\nrangeph = \"Rₘₐₓ= \" + str(round(max_R, 2)) + \" m\"    \nprint(rangeph)\n\nRₘₐₓ= 31.38 m\n\n\n\n#Time of flight calculation\nmax_tflighta = 2 * max_uy / g\nmax_apx = (max_ux * max_tflighta) / 2\n\n\n# Creates the figure\nfig, ax = plt.subplots()\n\n# Sets parameters of the plot\nax.set_xlabel(\"Displacement in x / m\")\nax.set_ylabel(\"Displacement in y / m\")\nax.set_ylim(0, y_graph)\nax.set_xlim(0, max_R)\n\n# Plots the graph\nax.plot(x, y, color=\"blue\", label=\"Custom Projectile\")\nax.plot(max_x, max_y, color=\"orange\", label=\"Maximum Range Projectile\")\n\n# Plots scatters showing the apogees of the trajectories\nax.scatter(apx, apy, color=\"blue\", marker=\"x\")\nax.scatter(max_apx, max_apy, color=\"orange\", marker=\"x\")\nax.grid()\n\nax.legend(loc=\"upper right\")"
  },
  {
    "objectID": "posts/cchallenge6.html",
    "href": "posts/cchallenge6.html",
    "title": "BPhO Computational Challenge 2024: Challenge 6: Calculating the Distance Travelled by a Drag-Free Projectile using Integration",
    "section": "",
    "text": "DISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo .\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\n\n\n# Retrieve parameters\nu = 25\nangle = 55\nh = 4\ng = 9.81\n\n\n# Converts from degrees to radians\ntheta = (angle * np.pi) / 180\n\n\n# Resloves forces into horizontal and vertical component\ncostheta = math.cos(theta)\nsintheta = math.sin(theta)\n\nux = u * costheta\nuy = u * sintheta\n\n\n# Calculates the range and time of flight of the projectile\nR = (u**2 / g) * (sintheta*costheta+costheta*math.sqrt(sintheta**2 + ((2 * g * h) / (u**2))))\ntflight = R / (u * costheta)\n\n\n# Creates an empty arrary for the x and y coordinates of the trajectory\nx = []\ny = []\n\n# Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\nfor i in np.arange(0, tflight, 0.01):\n    t = i\n    x.append(ux * t)\n    T = t * t\n    y.append(h + (uy * t) - (0.5 * g * T))\n\n\n# Apogee calculation\napy = (0 - (uy*uy)) / (2 * g * -1) + h\ntflight0 = 2 * uy / g\napx = (ux * tflight0) / 2\n\n\n# Generates the calculated values text\n# Time of flight phrase\nprint(\"Time of flight for custom projectile = \" + str(round(tflight, 2)) + \" s\")\n\n# Range phrase\nprint(\"Range for custom projectile = \" + str(round(R, 2)) + \" m\")\n\n# Distance travelled calculation\nlim1 = np.tan(theta)\nlim2 = np.tan(theta) - (g * R) / (u**2) * (1 + np.tan(theta)**2)\nsc = u**2 / (g * (1 + np.tan(theta)**2))\nlim1_calc = 0.5 * np.log(abs(np.sqrt(1 + lim1**2) + lim1)) + 0.5 * lim1 * np.sqrt(1 + lim1**2)\nlim2_calc = 0.5 * np.log(abs(np.sqrt(1 + lim2**2) + lim2)) + 0.5 * lim2 * np.sqrt(1 + lim2**2)\n\ns = sc * (lim1_calc - lim2_calc)\n\n# Distance travelled phrase\nprint(\"Displacement for custom projectile = \" + str(round(s, 2)) + \" m\")\n\n# Calculates maximum theta\nu2 = u * u\ntgh = 2 * g * h\ntghu2 = (tgh) / (u2)\narc = (1 / (math.sqrt(2 + tghu2)))\n\nthetamax = np.arcsin(arc)\n\nmax_ux = u * math.cos(thetamax)\nmax_uy = u * math.sin(thetamax)\n\n# Creates an empty array for the x and y coordinates of the trajectory\nmax_x = []\nmax_y = []\n\n# Calculates the range and time of flight of the projectile\nmax_R = (u**2 / g) * math.sqrt(1 + (2 * g * h/ u**2))\nmax_tflight = max_R / max_ux\n\n# Plots the maximum range projectile\nfor max_i in np.arange(0, max_tflight, 0.01):\n    max_t = max_i\n    max_x.append(max_ux * max_t)\n    max_T = max_t * max_t\n    max_y.append(h + (max_uy * max_t) - (0.5 * g * max_T))\n    \n# Apogee calculation\nmax_apy = (0 - (max_uy*max_uy)) / (2 * g * -1) + h\n\n# Compares the y values of the two apogees to set the y limit\ndef compapy(apy, max_apy):\n    if apy &gt; max_apy:\n        return apy\n    else:\n        return max_apy\ny_graph = compapy(apy, max_apy) * 1.1 \n\n# Generates the calculated values text\n# Time of flight phrase\nprint(\"Time of flight for maximised range projectile = \" + str(round(max_tflight, 2)) + \" s\")\n    \n# Range phrase\nprint(\"Range for maximised range projectile = \" + str(round(max_R, 2)) + \" m\")\n\n# Max distance travelled calculation\nmaxlim1 = np.tan(thetamax)\nmaxlim2 = np.tan(thetamax) - (g * max_R) / (u**2) * (1 + np.tan(thetamax)**2)\nmaxsc = u**2 / (g * (1 + np.tan(thetamax)**2))\nmaxlim1_calc = 0.5 * np.log(abs(np.sqrt(1 + maxlim1**2) + maxlim1)) + 0.5 * maxlim1 * np.sqrt(1 + maxlim1**2)\nmaxlim2_calc = 0.5 * np.log(abs(np.sqrt(1 + maxlim2**2) + maxlim2)) + 0.5 * maxlim2 * np.sqrt(1 + maxlim2**2)\n\nmaxs = maxsc * (maxlim1_calc - maxlim2_calc)\n\n# Max distance travelled phrase\nprint(\"Displacement for maximised range projectile = \" + str(round(maxs, 2)) + \" m\")\n\n#Time of flight calculation\nmax_tflighta = 2 * max_uy / g\nmax_apx = (max_ux * max_tflighta) / 2\n\n# Creates the figure\nfig, ax = plt.subplots()\n\n# Sets parameters of the plot\nax.set_xlabel(\"Displacement in x / m\")\nax.set_ylabel(\"Displacement in y / m\")\nax.set_ylim(0, y_graph)\nax.set_xlim(0, max_R)\n\n# Plots graphs and apogees\nax.plot(x, y, color=\"blue\", label=\"Custom Projectile\")\nax.plot(max_x, max_y, color=\"orange\", label=\"Maximum Range Projectile\")\nax.scatter(apx, apy, color=\"blue\")\nax.scatter(max_apx, max_apy, color=\"orange\")\nax.grid()\n\nax.legend(loc=\"upper right\")\n\nTime of flight for custom projectile = 4.36 s\nRange for custom projectile = 62.55 m\nDisplacement for custom projectile = 81.2 m\nTime of flight for maximised range projectile = 3.72 s\nRange for maximised range projectile = 67.59 m\nDisplacement for maximised range projectile = 77.7 m"
  },
  {
    "objectID": "posts/cchallenge8.html",
    "href": "posts/cchallenge8.html",
    "title": "BPhO Computational Challenge 2024: Challenge 8: Creating a Bouncing Projectile Model Using Verlet Integration",
    "section": "",
    "text": "DISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo .\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Initial Conditions\nu = 5\nC = 0.7\na = 45\nh = 10\nN = 6\ndt = 0.01\ng = 9.81\n\n\n# Verlet procedure\ndef verlet(N, C, g, dt, h, a, u):\n    # Initial conditions\n    a = a * (np.pi/180)\n    nbounce = 0\n    t = 0\n    x = 0\n    y = h\n    ux = u * np.cos(a)\n    uy = u * np.sin(a)\n\n    # Defines global arrays plotx and ploty\n    plotx = []\n    ploty = []\n\n    while nbounce &lt;= N:\n        # Acceleration\n        ax = 0\n        ay = -g\n\n        # Updating position\n        x = x + ux * dt + 0.5 * ax * dt**2\n        y = y + uy * dt + 0.5 * ay * dt**2\n            \n        # Appends x and y arrays\n        plotx.append(x)\n        ploty.append(y)\n\n        # Update acceleration (Stays the same)\n        aax = 0\n        aay = -g\n\n        # Update velocity\n        ux = ux + 0.5 * (ax + aax) * dt\n        uy = uy + 0.5 * (ay + aay) * dt\n\n        # Checks if the height of the ball is greater than 0\n        if y &lt; 0:\n            y = 0\n            uy = -C * uy\n            nbounce = nbounce + 1\n\n        t = t + dt\n\n    # Time of flight of the ball\n    tflight = t\n\n    return tflight, plotx, ploty\n\ntflight, plotx, ploty = verlet(N, C, g, dt, h, a, u)\n\n\n# Generates the calculated values text\n# Time of flight phrase\ntflightph = \"Time of flight: \" + str(round(tflight, 2)) + \" s\"\nprint(tflightph)\n\nTime of flight: 8.08 s\n\n\n\n# Plotting and grid\nfig, ax = plt.subplots()\nax.plot(plotx, ploty)\nax.set_xlabel(\"Displacement in x / m\")\nax.set_ylabel(\"Displacement in y / m\")\nax.grid()\n\n# Axes limits\nax.set_xlim(0)\nax.set_ylim(0)\n\nplt.show()"
  },
  {
    "objectID": "posts/cchallengee1.html",
    "href": "posts/cchallengee1.html",
    "title": "BPhO Computational Challenge 2024: Extension: Creating a Projectile Model Incorporating both Air Resistance and Varying Air Density with Height Using Verlet Integration",
    "section": "",
    "text": "Introduction\nDISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo .\n\n\nSetting up the Problem\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\n\n\n# Input parameters\nangle = 30\nu = 100\ng = 9.81\nh = 1000\nA = 0.002\nc_drag = 0.1\nm = 0.01\ndt = 0.01\ndensity = 1.225\n\n\n# Converts the angle to radians\ntheta = (angle * np.pi) / 180\n\n# Resloves forces into horizontal and vertical component\ncostheta = math.cos(theta)\nsintheta = math.sin(theta)\n\nux = u * costheta\nuy = u * sintheta\n\n\n\nNo Air Resistance\n\n# Calculates the range and time of flight of the projectile\nR = (u**2 / g) * (sintheta*costheta+costheta*math.sqrt(sintheta**2 + ((2 * g * h) / (u**2))))\ntflight = R / (u * costheta)\n\n# Time of flight phrase\nprint(\"Time of flight: \" + str(round(tflight, 2)) + \" s\")\n\n# Range phrase\nprint(\"Range: \" + str(round(R, 2)) + \" m\")   \n\nTime of flight: 20.26 s\nRange: 1754.37 m\n\n\n\n# Creates an empty arrary for the x and y coordinates of the trajectory\nx = []\ny = []\n\n# Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\nfor i in np.arange(0, tflight, 0.01):\n    t = i\n    x.append(ux * t)\n    T = t * t\n    y.append(h + (uy * t) - (0.5 * g * T))\n\n\n# Apogee calculation\napy = (0 - (uy*uy)) / (2 * g * -1) + h\ny_graph = apy + apy * 0.1\n\n\n\nAir Resistance\n\n# Calculation for k\nk = (0.5 * c_drag * density * A) / m\n\n\n# Creates arrays for air resistance x and y values\nx_plot = []\ny_plot = []\n\n# Sets initial x and y values\nd_x = 0\nd_y = h\n\n# Adds initial x and y values to the arrays\nx_plot.append(d_x)\ny_plot.append(d_y)\n\n# Verlet method to update the acceleration, velocity and position of the projectile after each discrete timestep\nn = 0\nt_drag = 0\nwhile y_plot[n] &gt;= 0:\n    t_drag = t_drag + dt\n    ax = - (ux / u) * k * u**2\n    ay = - g - (uy / u) * k * u**2\n    d_x = d_x + ux * dt + 0.5 * ax * dt**2\n    d_y = d_y + uy * dt + 0.5 * ay * dt**2\n    x_plot.append(d_x)\n    y_plot.append(d_y)\n    ux = ux + ax * dt\n    uy = uy + ay * dt\n    u = math.sqrt(ux**2 + uy**2)\n    n += 1\n\nR_drag = x_plot[n]\n\n\n# Generates the calculated values text\n# Time of flight phrase\nprint(\"Time of flight (drag): \" + str(round(t_drag, 2)) + \" s\")\n    \n# Range phrase\nprint(\"Range (drag): \" + str(round(R_drag, 2)) + \" m\")\n\nTime of flight (drag): 41.15 s\nRange (drag): 179.22 m\n\n\n\n\nAir Resistance and Varying Air Density with Height\n\n# Parameters for non linear air resistance\n# Sea level standard atmospheric pressure\np0 = 101325\n# Intial height\nh0 = h\n# Specific gas constant for air\nsgc = 287.052874\n# mass of one air molecule\nmass_am = 4.81e-26\n# Boltzmann constant\nkB = 1.380649e-23\n# Initial temperature in Celsius (standard temperature at sea level)\nT0 = 15\n\nx_air = 0\ny_air = h\n\nux = u * costheta\nuy = u * sintheta\n\nd_x = 0\nd_y = h\n\n\n# Verlet method for varying air density\ndef verlet_air(p0, h0, sgc, mass_am, kB, T0, d_x, d_y, ux, uy, m, A, dt, c_drag, u, h, density):\n    t = 0\n    x_air_plot = []\n    y_air_plot = []\n\n    x_air_plot.append(d_x)\n    y_air_plot.append(d_y)\n    \n    n = 0\n    while y_air_plot[n] &gt;= 0:\n        k = (0.5 * c_drag * density * A) / m\n\n        ax = - (ux / u) * k * u**2\n        ay = - g - (uy / u) * k * u**2\n        d_x = d_x + ux * dt + 0.5 * ax * dt**2\n        d_y = d_y + uy * dt + 0.5 * ay * dt**2\n        x_air_plot.append(d_x)\n        y_air_plot.append(d_y)\n        ux = ux + ax * dt\n        uy = uy + ay * dt\n        u = math.sqrt(ux**2 + uy**2)\n        h = d_y\n\n        temp = T0 - h * 0.00650\n        temp = temp + 273.15\n        p = p0 * math.exp((-mass_am * g * h) / (kB * temp))\n        density = p / (sgc * temp)\n\n        n += 1\n\n        t = t + dt\n\n    return x_air_plot, y_air_plot, n, t\n\nx_air_plot, y_air_plot, n, t_air = verlet_air(p0, h0, sgc, mass_am, kB, T0, x_air, y_air, ux, uy, m, A, dt, c_drag, u, h, density)\n\nR_air = x_air_plot[n]\n\n\n# Generates the calculated values text\n# Time of flight phrase\nprint(\"Time (varying air density): \" + str(round(t_air, 2)) + \" s\")\n\n# Range phrase\nprint(\"Range (varying air density): \" + str(round(R_air, 2)) + \" m\")    \n\nTime (varying air density): 38.2 s\nRange (varying air density): 97.53 m\n\n\n\n# Creates the figure\nfig, ax = plt.subplots()\n\n# Sets the parameters of the plot\nax.set_xlabel(\"Displacement in x / m\")\nax.set_ylabel(\"Displacement in y / m\")\nax.set_ylim(0, y_graph)\nax.set_xlim(0, R)\n\n# Components to be plotted\nax.plot(x, y, label=\"No Air Resistance\")\nax.grid()\nax.plot(x_plot, y_plot, label=\"Air Resistance\")\nax.plot(x_air_plot, y_air_plot, label = \"Air Resistance and Varying Air Density\")\n\nax.legend()"
  },
  {
    "objectID": "posts/gcd.html",
    "href": "posts/gcd.html",
    "title": "Computing the Greatest Common Divisior (GCD) Using the Euclidean Algorithm",
    "section": "",
    "text": "Introduction\nEuclid’s algorithm to find the Greatest Common Divisor (GCD), that is the largest number that divides two positive integers without a remainder, was first described in the 7th book of Euclid’s Elements written c. 300 BC, making it one of the oldest algorithms.\nThe algorithm works by using the fact that the GCD of two numbers, a and b, is the same as the GCD of b and the remainder of a divided by b. In Python, this is achieved using the modulo function, or %. This process is then repeated until there is no remainder.\nThe Euclidean algorithm has a time complexity of O(log(min(a, b))).\nInterestingly, the extended Euclidian algorithm calculates the coefficients of Bézout’s identity such that \\(ax+by=gcd(a,b)\\). This is used in solving Diophantine equations and in modular arithmetic, for instance, the RSA encryption algorithm when calculating the modular inverses for key generation.\n\n\nInputs\nThe algorithm requires two inputs - two positive integers, a and b. Normally, the user would be asked to input these integers, however, for the purpose of this example, I have used the integers shown below.\n\n# Defining positive integers a and b\na = 2376\nb = 4832\n\n\n\nFunction to Perform Euclid’s Algorithm\nThe function consists of a while loop which only stops when the remainder is 0 (and therefore the algorithm has found the GCD). First, the remainder of a divided by b is calculated using the modulo (%) function. Then, b is set to a, and the remainder is set to b in order to repeat the algorithm until the GCD is found.\n\n# Function to perform the Euclidian algorithm\ndef gcd(a,b):\n    while b != 0:\n        remainder = a % b\n        a = b\n        b = remainder\n\n    return a\n\n\n\nOutput\nTo output the GCD, the program calls the function, passes the two integers a and b, and prints the result.\n\n# Outputs the GCD\nprint(\"The Greatest Common Divisor (GCD) is\", gcd(a, b))\n\nThe Greatest Common Divisor (GCD) is 8"
  },
  {
    "objectID": "posts/montecarlo.html",
    "href": "posts/montecarlo.html",
    "title": "Monte Carlo Simulation: Estimating π",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport random\nimport numpy as np\n\n\n# The total number of coordinates in the square\ntotal_points = 10000000\n\n# Generates a random set of x and y coordinates inside the square\nx = np.random.uniform(0, 5, total_points)\ny = np.random.uniform(0, 5, total_points)\n\n\n# Calculate squared distance from center of the circle\nr_squared = (x - 2.5)**2 + (y - 2.5)**2\n\n# Placing points inside the circle\ninside_circle = r_squared &lt;= 2.5**2\n\n# Count points inside the circle\npoints_in_circle = np.sum(inside_circle)\n\n\n# Creates a square\nfig, ax = plt.subplots()\nsquare = patches.Rectangle((0, 0), 5, 5, edgecolor='blue', facecolor='none')\n\n# Creates a circle\ncircle = plt.Circle((2.5, 2.5), 2.5, color='red', fill=False)\n\n# Plotting the points\nplt.scatter(x[~inside_circle], y[~inside_circle], color=\"blue\", s=0.1)\nplt.scatter(x[inside_circle], y[inside_circle], color=\"red\", s=0.1)\nax.add_patch(square)\nax.add_patch(circle)\n\n# Sets parameters of the plot\nplt.xlim(-1, 6)\nplt.ylim(-1, 6)\nplt.gca().set_aspect('equal', adjustable='box')  # Ensures equal aspect ratio\nplt.title('Monte Carlo Simulation')\nplt.show()\n\n\n\n\n\n\n\n\n\n# Approximating pi\npi = 4 * points_in_circle / total_points\nprint(pi)\n\n3.1412656"
  },
  {
    "objectID": "posts/optimisation.html",
    "href": "posts/optimisation.html",
    "title": "Optimisation: The Gradient Descent Algorithm for Maching Learning",
    "section": "",
    "text": "Introduction\nThe objective of this blog post is to create an implementation of a one-dimensional gradient descent algorithm used for optimisation in machine learning where a function needs to be minimised. Shown below is the code and explanations of my implementation of the algorithm.\n\n\nSetting up the Problem\nFirst, the required libraries are imported and the function f(x) is defined for future use. This can be changed to any function that the user would require. In this example, I have used the equation \\(f(x)=x\\sin(x)+\\cos(x)+x\\).\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Creates the function\ndef f(x):\n    return x * np.sin(x) + (np.cos(x) + x)\n\n\n\nCalculating the Derivative\nThis function calculates the numerical derivative using the central difference method and a small step ϵ. This is defined by the equation \\(f'(x)\\approx\\frac{f(x + \\epsilon)-f(x - \\epsilon)}{2\\epsilon}\\). For a more detailed analysis of this function, check out my previous post here:  Calculating the Numerical Derivative using the Central Difference Method .\n\n# Function to differentiate\ndef derivative(f, x):\n    eps = 1e-8\n    der = (f(x + eps) - f(x - eps)) / (2 * eps)\n    \n    return der\n\n\n\nCreating the Gradient Descent Algorithm Function\nThe following function performs the gradient descent algorithm. There are two stopping conditions for the algorithm, a maximum number of iterations, and if the absolute value of the gradient is lower than a set threshold value. The variable alpha is the learning rate of the algorithm, a scalar quantity which controls the size of the steps the algorithm takes. The equation \\(\\theta_{t+1}=\\theta_t-\\alpha\\nabla_{\\theta}f(\\theta_t)\\) is used to update the position of the marker until the minimum point is found.\n\n# Function to perform the gradient descent algorithm\ndef descent(f, derivative, xk, alpha=1e-3, tol=1e-4, max_iters=10000):\n    for i in range(max_iters):\n        grad = derivative(f, xk)\n        if abs(grad) &lt; tol:\n            break\n        xk = xk - alpha * grad\n\n    return xk\n\n\n\nFinding Minima\nThe algorithm is then ran from various different starting points until the lowest minima is found. Empty lits of x and y coordinates are created and appended to with the coordinates determined by the algorithm. In this example, I used starting points between -12 and 12. The y coordinate of the optimal minimum point is then determined and printed.\n\nxk_points = []\nyk_points = []\nfor i in np.arange(-12,12):\n    # Starting position\n    xk = i\n    # Finds the x coordinate of each minima\n    xk = descent(f, derivative, xk)\n    xk_points.append(xk)\n\n    # Finds the y coordinate of the minima for plotting\n    yk = f(xk)\n    yk_points.append(yk)\n\n# Prints the y coordiante of the optimal minimum\nprint(\"The optimal minimum has y coordinate\", min(yk_points))\n\nThe optimal minimum has y coordinate -22.036404343345218\n\n\n\n\nPlotting the Function, Derivative and Minima\nThe below code generates the function, its derivative and the minima found by the algorithm.\n\n# Creates an array of x coordinates and finds corresponding y coordinates \n# for plotting\nx = np.linspace(-15, 15, 100)\ny = f(x)\n\n# Differentiates x coordinates to create the graph of the first derivative\ndydx = np.array([derivative(f, xi) for xi in x])\n\n# Plots the curves\nplt.plot(x, y, label=\"f(x)\")\nplt.plot(x, dydx, label=\"f'(x)\")\nplt.scatter(xk_points, yk_points, marker=\"x\", color=\"red\", label=\"Minima\")\n\n# Sets parameters of the plot and plots the curves\nplt.xlim(-15, 15)\nplt.grid()\nplt.legend()\n\nplt.show()"
  }
]