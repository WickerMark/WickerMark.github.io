[
  {
    "objectID": "posts/primes.html",
    "href": "posts/primes.html",
    "title": "Generating the nth Prime Number",
    "section": "",
    "text": "Introduction\nThe ability to generate prime numbers is important for a variety of tasks, most notably, cryptography, the RSA algorithm for instance, in psuedo-random number generation and benchmarking algorithms.\n\n\nSetting up the Problem\nNumpy will be used for the square root function later in the code.\nAn array used to store the prime numbers is created and the first two prime numbers are stored.\nNumber, the variable used to represent the current number to be checked if it is prime, is set to 3. This means that the counter, used to represent how many prime numbers have been found, is set to 2, since 3 is the second prime number.\n\nimport numpy as np\n\nprime_list = [2, 3]\nnumber = 3\ncounter = 2\n\nThe prime number to be generated can be set to anything, but for this example, I have used 1000. This means that the while loop will continue to iterate until the counter is no longer less than 1000.\n\n\nCalculating and Outputting the nth Prime Number\nThe variable number is first incremented by 2 (to emit all even numbers since these cannot be prime).\nA new variable, called prime, stores a boolean value which states if a number is prime or not. Initially, prime is set to True.\nA for loop is used to check if number is divisible by previous prime numbers.\nThe square root function is used here because if the index of the prime number to be checked is greater than the square root of the number, it is not a factor. If this statement is true, the code breaks out of the for loop.\nHere, I use the modulo operator to determine if the number has a remainder when dividing by previous prime numbers. If it does, the number is determined as a composite number, and so prime is set to False.\nThe final if statement is used such that if the number was determined to be prime, the counter would be incremented, and the number would be appended to the list of prime numbers so that future numbers can be checked against it.\nFinally, counter is cast as a string and concatenated to output the nth prime number.\n\nwhile counter &lt; 1000:\n    number += 2\n    prime = True\n    for i in prime_list:\n        if i &gt; np.sqrt(number):\n            break\n        elif number % i == 0:\n            prime = False\n            break\n    \n    if prime == True:\n        counter += 1\n        prime_list.append(number)\nprint(\"The\", str(counter) + \"th prime number is\", number)\n\nThe 1000th prime number is 7919"
  },
  {
    "objectID": "posts/derivative.html",
    "href": "posts/derivative.html",
    "title": "A Numerical Method to Calculate the Derivative using a Small Step, ϵ",
    "section": "",
    "text": "Introduction\nThe algorithm created is based on the equation \\(f'(x)\\approx\\frac{f(x + \\epsilon)-f(x - \\epsilon)}{2\\epsilon}\\) to approximate the derivative using a small step. I have set the small step to \\(\\epsilon=1\\times10^{-8}\\), however, this can be modified to the specification of the user.\n\n\nSetting up the Problem\nTo begin the algorithm, the required libraries are imported, specifically numpy for trigonometric and logarithmic functions and matplotlib for the plotting.\nNext, the function to be differentiated is defined. For the purpose of this example, the function used is \\(f(x)=\\ln(x^2)\\sin(x)\\). The user can change the function to whatever may be required.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Creates the function\ndef f(x):\n    return np.log(x**2) * np.sin(x)\n\n\n\nCalculating the Derivative\nThis function finds the derivative using the small step, ϵ, at a given x coordinate. This is useful for plotting, because the desired array of x coordinates can be passed to the function to generate an f’(x) function for that set of values. For other algorithms, the gradient descent algorithm for instance, finding the derivative at a given x coordinate is useful for further calculations.\n\n# Function to differentiate\ndef derivative(f, x):\n    eps = 1e-8\n    der = (f(x + eps) - f(x - eps)) / (2 * eps)\n    \n    return der\n\n\n\nOutputting a Graph of the Derivative\nHere, np.linspace(-15, 15, 500) is used to create an equally spaced array of 500 x coordinates between x = -15 and x = 15. Then, for each x coordinate, a corresponding y coordinate is found by passing each x coordinate into the function.\n\n# Creates an array of x coordinates and finds corresponding y coordinates \n# for plotting\nx = np.linspace(-15, 15, 500)\ny = f(x)\n\nNow, list comprehension is used to apply the derivative function to each element \\(x_i\\) in \\(x\\). The result is then stored as a numpy array for plotting.\n\n# Differentiates x coordinates to create the graph of the first derivative\ndydx = np.array([derivative(f, xi) for xi in x])\n\nLastly, the curves f(x) and f’(x) are plotted and given appropriate labels.\nThen, the paramaters of the plot are set, the limit for the x axis, the creation of a grid and also the legend to display labels.\nThese graphs are then displayed.\n\n# Plots the curves\nplt.plot(x, y, label=\"f(x)\")\nplt.plot(x, dydx, label=\"f'(x)\")\n\n# Sets parameters of the plot and plots the curves\nplt.xlim(-15, 15)\nplt.grid()\nplt.legend()\n\nplt.show()\n\n\n\n\n\n\n\n\nThis algorithm has been curated for use in the gradient descent algorithm, which will be a future post."
  },
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "Coding Projects",
    "section": "",
    "text": "A Numerical Method to Calculate the Derivative using a Small Step, ϵ\n\n\n\n\n\n\nPython\n\n\nNumerical Methods\n\n\n\nAn implementation of calculating the numerical derivative using the small step, ϵ, in Python, for the purpose of plotting and use in the gradient descent algorithm.\n\n\n\n\n\nJul 28, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 3: Creating a Simple Analytical Drag-Free Projectile Model\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the first two challenges of the BPhO Computational Challenge, an analytical projectile model which creates a trajectory and outputs time of flight, range and the apogee.\n\n\n\n\n\nMar 24, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 4: Creating a Simple Analytical Drag-Free Projectile Model\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the first two challenges of the BPhO Computational Challenge, an analytical projectile model which creates a trajectory and outputs time of flight, range and the apogee.\n\n\n\n\n\nApr 9, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 5: Implementing the Bounding Parabola to the Projectile Model\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the first two challenges of the BPhO Computational Challenge, an analytical projectile model which creates a trajectory and outputs time of flight, range and the apogee.\n\n\n\n\n\nApr 11, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 6: Calculating the Distance Travelled by a Drag-Free Projectile using Integration\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the first two challenges of the BPhO Computational Challenge, an analytical projectile model which creates a trajectory and outputs time of flight, range and the apogee.\n\n\n\n\n\nMay 5, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 7: An Examination of the Phenomenon of Local Maxima and Minima on Range Against Time Graphs in Projectile Motion\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the first two challenges of the BPhO Computational Challenge, an analytical projectile model which creates a trajectory and outputs time of flight, range and the apogee.\n\n\n\n\n\nMay 19, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 8: Bouncing Projectile Model\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the first two challenges of the BPhO Computational Challenge, an analytical projectile model which creates a trajectory and outputs time of flight, range and the apogee.\n\n\n\n\n\nMay 26, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenge 9: Creating a Projectile Model Incorporating Air Resistance\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the first two challenges of the BPhO Computational Challenge, an analytical projectile model which creates a trajectory and outputs time of flight, range and the apogee.\n\n\n\n\n\nMay 9, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Challenges 1 & 2: Creating a Simple Analytical Drag-Free Projectile Model\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the first two challenges of the BPhO Computational Challenge, an analytical projectile model which creates a trajectory and outputs time of flight, range and the apogee.\n\n\n\n\n\nMar 7, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge 2024: Extension: Creating a Projectile Model Incorporating both Air Resistance and Varying Air Density with Height\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the first two challenges of the BPhO Computational Challenge, an analytical projectile model which creates a trajectory and outputs time of flight, range and the apogee.\n\n\n\n\n\nJun 10, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nBPhO Computational Challenge: Challenges 1 & 2 2024: Creating a Simple Analytical Drag-Free Projectile Model\n\n\n\n\n\n\nPython\n\n\nBPhO Computational Challenge\n\n\nComputational Physics\n\n\nProjectile Motion\n\n\n\nThe solution to the first two challenges of the BPhO Computational Challenge, an analytical projectile model which creates a trajectory and outputs time of flight, range and the apogee.\n\n\n\n\n\nApr 11, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nGenerating the nth Prime Number\n\n\n\n\n\n\nPython\n\n\nPrime Numbers\n\n\n\nPython program which calculates an inputted nth prime number by dividing each consecutive number by previous prime numbers.\n\n\n\n\n\nAug 14, 2024\n\n\nMark Watson\n\n\n\n\n\n\n\n\n\n\n\n\nOptimisation: The Gradient Descent Algorithm for Maching Learning\n\n\n\n\n\n\nPython\n\n\nOptimisation\n\n\nMachine Learning\n\n\n\nPython program which uses the gradient descent algorithm to calculate minimum points for a given function. Used for optimisation in machine learning.\n\n\n\n\n\nAug 13, 2024\n\n\nMark Watson\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html#python-experience",
    "href": "about.html#python-experience",
    "title": "Mark Watson",
    "section": "Python Experience",
    "text": "Python Experience\nI have about 5 years of experience in Python, creating various projects and entering in competitions with Python, some of which are shown in the coding projects tab. Most notably, I have entered, along with my partner, into the BPhO Computational Challenge 2024."
  },
  {
    "objectID": "about.html#bpho-computational-challenge-2024",
    "href": "about.html#bpho-computational-challenge-2024",
    "title": "Mark Watson",
    "section": "BPhO Computational Challenge 2024",
    "text": "BPhO Computational Challenge 2024\nThe aim of the challenge is to solve classical Physics problems computationally. For the 2024 rendition of the challenge, we created a GUI application consisting of 9 projectile models, including a projectile model considering both air restistance and varying air density with height. During the challenge, I also learnt how to write scientific papers using LaTex, one of the extensions of the competition."
  },
  {
    "objectID": "about.html#machine-learning",
    "href": "about.html#machine-learning",
    "title": "Mark Watson",
    "section": "Machine Learning",
    "text": "Machine Learning\nMost of my experience in machine learning is in the applications of machine learning, such as applying machine learning algorithms to galaxy classification, see my EPQ. Some of my projects have involved rudimentary machine learning algorithms, for instance, I explored how the gradient descent algorithm and optimisation could be used"
  },
  {
    "objectID": "about.html#epq",
    "href": "about.html#epq",
    "title": "Mark Watson",
    "section": "EPQ",
    "text": "EPQ"
  },
  {
    "objectID": "about.html#web-development",
    "href": "about.html#web-development",
    "title": "Mark Watson",
    "section": "Web Development",
    "text": "Web Development\nThroughout the course of developing this and other websites, I have gained a lot of experience in HTML and CSS. While developing this website, I gained many valuable skills and learnt a lot, such as how Git works, using version control, developing websites and blogs using Quarto, creating mathematical expressions with LaTex and using GitHub and GitHub pages."
  },
  {
    "objectID": "about.html#astrophotography",
    "href": "about.html#astrophotography",
    "title": "Mark Watson",
    "section": "Astrophotography",
    "text": "Astrophotography\nIn my free time, I enjoy capturing images of distant deep sky objects using astrophotography. Click the astrophotograhy tab to see my portfolio."
  },
  {
    "objectID": "about.html#chess",
    "href": "about.html#chess",
    "title": "Mark Watson",
    "section": "Chess",
    "text": "Chess\nI am also a passionate chess player. I have several high tournament finishes in my category, including a bronze at the presitigious Doncaster Chess Congress and a silver at the Darnall & Handsworth Rapidplay September 2023. I have also regularly represented my local town, Rotherham, in the second division of the Sheffield & District Chess Association for the past 3 years. I founded and captained the Wickersley School Chess Club (my secondary school and sixth form) for the past 5 years and volunteered my time to tutor the younger students."
  },
  {
    "objectID": "about.html#languages",
    "href": "about.html#languages",
    "title": "Mark Watson",
    "section": "Languages",
    "text": "Languages\nFinally, I love learning languages. I am fluent in Polish and have been learning Russian and German for the past few years."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Welcome to my portfolio of programming projects and competition submissions\n\n\nFeatured Projects\n\n\n\nGenerating the nth prime number\n\n\nOptimisation\n\n\n\n\n\nBPhO Computational Challenge 2024:\n\nVideo Submission\n\n\n\n\nCode and Explanations\n\n\n\nChallenge 1 & 2: Analytical Drag-Free Projectile Model\n\n\nChallenge 1 & 2: Analytical Drag-Free Projectile Model\n\n\nChallenge 1 & 2: Analytical Drag-Free Projectile Model\n\n\nChallenge 1 & 2: Analytical Drag-Free Projectile Model\n\n\nChallenge 1 & 2: Analytical Drag-Free Projectile Model\n\n\nChallenge 1 & 2: Analytical Drag-Free Projectile Model\n\n\nChallenge 1 & 2: Analytical Drag-Free Projectile Model\n\n\nChallenge 1 & 2: Analytical Drag-Free Projectile Model\n\n\nChallenge 1 & 2: Analytical Drag-Free Projectile Model\n\n\nChallenge 1 & 2: Analytical Drag-Free Projectile Model"
  },
  {
    "objectID": "posts/cchallenge1.html",
    "href": "posts/cchallenge1.html",
    "title": "BPhO Computational Challenge 2024: Challenge 1 & 2: Creating a Simple Analytical Drag-Free Projectile Model",
    "section": "",
    "text": "Introduction\nThe below code is my implementation of the first and second challenge of the BPhO Computational Challenge 2024. The objective was to create an exact analytical model of projectile motion without air resistance.\nDISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo .\n\n\nSetting up the Problem\nFirst, the plotting library matplotlib is imported, which will be used to plot the trajectory of the projectile. Also, numpy will be imported for its trigonometric and mathematical functions.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nThe program takes inputs \\(\\theta\\), \\(u\\), \\(g\\) and \\(h\\). The commented out sections of code show how the user would be asked to input these. In this example, I have used \\(\\theta=37\\), \\(u=23.31\\), \\(g=9.81\\) and \\(h = 12.32\\). The angle entered in degrees is converted into radians for future use.\n\n# Enables the user to enter conditions for the trajectory\n# angle = float(input(\"Enter the angle of projection in degrees: \"))\nangle = 37\ntheta = (angle * np.pi) / 180\n\n# u = float(input(\"Enter the intitial velocity of the projectile: \"))\nu = 23.31\n\ng = 9.81\n\n# h = float(input(\"Enter the height above the ground of the projectile: \"))\nh = 12.32\n\nThis section of code prevents the user inputting an invalid height less than 0.\n\nif h &lt; 0:\n    print(\"ERROR Height must be greater than 0\")\n    exit()\n\nThe variables costheta and sintheta are created since they are used frequently in the program. Then, the velocity is resolved into horizontal and vertical components using the equations \\(u_x=u\\cos\\theta\\) and \\(u_y=u\\sin\\theta\\).\n\n# Resloves forces into horizontal and vertical component\ncostheta = np.cos(theta)\nsintheta = np.sin(theta)\n\nux = u * costheta\nuy = u * sintheta\n\n\n\nCalculating the Range\nNow, the program calculates the range of the projectile and outputs the calculated value. This is achieved using the equation \\(R=\\frac{u^2}{g}(\\sin\\theta\\cos\\theta+\\cos\\theta\\sqrt{\\sin^2\\theta+\\frac{2gh}{u^2}})\\). The x_graph variable is used to determine the highest x coordinate displayed on the plot, which is determined from the range. This is purely aesthetic.\n\nR = (u**2 / g) * (sintheta * costheta + costheta * np.sqrt(sintheta**2 + (2 * g * h)/ (u**2)))\nprint(\"The range is\", round(R, 2), \"m\")\nx_graph = R + R * 0.1\n\nThe range is 66.36 m\n\n\n\n\nCalculating the Time of Flight\nThe time of flight is then calculated using the general time equation and the range. The equation for the time of flight at a given x coordinate is \\(t=\\frac{x}{u_x}\\) so the time of flight across the range is \\(T=\\frac{R}{u_x}\\). The calculated value is then output along with a phrase.\n\n#Time of flight calculation\ntflight = R / ux\nprint(\"The time of flight is\", round(tflight, 2), \"s\")  \n\nThe time of flight is 3.56 s\n\n\n\n\nComputing the Trajectory of the Drag-Free Projectile\nAn empty list of x and y coordinates are created. These will then be appended to when the position of the projectile is updated.\nA for loop with a timestep of 0.01s, updates the position of the projectile between 0s and the time of flight every 0.01s. The equations \\(x=u_xt\\) and \\(y=h+u_yt-\\frac{1}{2}gt^2\\) are used to update the x and y coordinates respectively at a given time, \\(t\\).\n\n# Creates an empty arrary for the x and y coordinates of the trajectory\nx = []\ny = []\n\n# Plots the parabolic path of the projectile with a timestep of 0.01s and an interval of 10s\nfor i in np.arange(0, tflight, 0.01):\n    t = i\n    x.append(ux * t)\n    T = t * t\n    y.append(h + (uy * t) - (0.5 * g * T))\n    t += 1\n\n\n\nCalculating the Apogee\nThen, the x and y coordinates of the apogee are calculated using the equations \\(x_a=\\frac{u^2}{g}\\sin\\theta\\cos\\theta\\) and \\(y_a=h+\\frac{u^2}{2g}\\sin^2\\theta\\). The y_graph variable is used to determine the y limit of the graph, the highest y coordinate displayed. Finally, a phrase is created which outputs the coordinates of the apogee.\n\n# Apogee calculation\napx = u**2 / g * sintheta * costheta\n\napy = h + u**2 / (2 * g) * sintheta**2\ny_graph = apy + apy * 0.1\n\nprint(\"The apogee is at (\", round(apx, 2), \",\", round(apy, 2), \")\")\n\nThe apogee is at ( 26.62 , 22.35 )\n\n\n\n\nPlotting the Trajectory\nFor the last portion of code, the graph is plotted along with the coordinates of the apogee. The parameters of the graph are then set, including labels and limits, and then the graph is plotted.\n\nplt.plot(x, y)\nplt.scatter(apx, apy, marker=\"x\", color=\"red\")\n\nplt.xlabel(\"Displacement in x / m\")\nplt.ylabel(\"Displacement in y / m\")\nplt.ylim(0, y_graph)\nplt.xlim(0, x_graph)\nplt.show()"
  },
  {
    "objectID": "posts/optimisation.html",
    "href": "posts/optimisation.html",
    "title": "Optimisation: The Gradient Descent Algorithm for Maching Learning",
    "section": "",
    "text": "Introduction\nThe objective of this blog post is to create an implementation of a one-dimensional gradient descent algorithm used for optimisation in machine learning where a function needs to be minimised. Shown below is the code and explanations of my implementation of the algorithm.\n\n\nSetting up the Problem\nFirst, the required libraries are imported and the function f(x) is defined for future use. This can be changed to any function that the user would require. In this example, I have used the equation \\(f(x)=x\\sin(x)+\\cos(x)+x\\).\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Creates the function\ndef f(x):\n    return x * np.sin(x) + (np.cos(x) + x)\n\n\n\nCalculating the Derivative\nThis function calculates the numerical derivative using the small step ϵ. This is defined by the equation \\(f'(x)\\approx\\frac{f(x + \\epsilon)-f(x - \\epsilon)}{2\\epsilon}\\).\n\n# Function to differentiate\ndef derivative(f, x):\n    eps = 1e-8\n    der = (f(x + eps) - f(x - eps)) / (2 * eps)\n    \n    return der\n\n\n\nCreating the Gradient Descent Algorithm Function\nThe following function performs the gradient descent algorithm. There are two stopping conditions for the algorithm, a maximum number of iterations, and if the absolute value of the gradient is lower than a set threshold value. The variable alpha is the learning rate of the algorithm, a scalar quantity which controls the size of the steps the algorithm takes. The equation \\(\\theta_{t+1}=\\theta_t-\\alpha\\nabla_{\\theta}f(\\theta_t)\\) is used to update the position of the marker until the minimum point is found.\n\n# Function to perform the gradient descent algorithm\ndef descent(f, derivative, xk, alpha=1e-3, tol=1e-4, max_iters=10000):\n    for i in range(max_iters):\n        grad = derivative(f, xk)\n        if abs(grad) &lt; tol:\n            break\n        xk = xk - alpha * grad\n\n    return xk\n\n\n\nFinding Minima\nThe algorithm is then ran from various different starting points until the lowest minima is found. Empty lits of x and y coordinates are created and appended to with the coordinates determined by the algorithm. In this example, I used starting points between -12 and 12. The y coordinate of the optimal minimum point is then determined and printed.\n\nxk_points = []\nyk_points = []\nfor i in np.arange(-12,12):\n    # Starting position\n    xk = i\n    # Finds the x coordinate of each minima\n    xk = descent(f, derivative, xk)\n    xk_points.append(xk)\n\n    # Finds the y coordinate of the minima for plotting\n    yk = f(xk)\n    yk_points.append(yk)\n\n# Prints the y coordiante of the optimal minimum\nprint(\"The optimal minimum has y coordinate\", min(yk_points))\n\nThe optimal minimum has y coordinate -22.036404343345218\n\n\n\n\nPlotting the Function, Derivative and Minima\nThe below code generates the function, its derivative and the minima found by the algorithm.\n\n# Creates an array of x coordinates and finds corresponding y coordinates \n# for plotting\nx = np.linspace(-15, 15, 100)\ny = f(x)\n\n# Differentiates x coordinates to create the graph of the first derivative\ndydx = np.array([derivative(f, xi) for xi in x])\n\n# Plots the curves\nplt.plot(x, y, label=\"f(x)\")\nplt.plot(x, dydx, label=\"f'(x)\")\nplt.scatter(xk_points, yk_points, marker=\"x\", color=\"red\", label=\"Minima\")\n\n# Sets parameters of the plot and plots the curves\nplt.xlim(-15, 15)\nplt.grid()\nplt.legend()\n\nplt.show()"
  },
  {
    "objectID": "posts/cchallenge7.html",
    "href": "posts/cchallenge7.html",
    "title": "BPhO Computational Challenge 2024: Challenge 7: An Examination of the Phenomenon of Local Maxima and Minima on Range Against Time Graphs in Projectile Motion",
    "section": "",
    "text": "DISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo . To begin, the necessary librariesa are imported. Matplotlib is used for plotting, numpy is used for mathematical and trigonometric functions, and figure is imported from matplotlib to create two graphs which are displayed.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.figure import Figure\n\n\n# Function to plot r\ndef rplot(a):\n    # Paramaters\n    u = 10\n    g = 10\n\n    arad = (a * np.pi) / 180\n\n    # Sin and cos of the angle\n    sintheta = np.sin(arad)\n\n    # Creates array of r and t valuse\n    range = []\n\n    # Appends array with inital conditions\n    range.append(0)\n\n    # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n    for i in np.arange(0, 2.6, 0.01):\n        t = i\n        r = np.sqrt(u**2 * t**2 - g * t**3 * u * sintheta + 0.25 * g**2 * t**4)\n        range.append(r)\n    \n    return range\n\n\n# Function to plot t\ndef tplot():\n\n    # Creates array for time valuse\n    time = []\n\n    # Appends array with inital condition\n    time.append(0)\n\n    # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n    for i in np.arange(0, 2.6, 0.01):\n        t = i\n        time.append(t)\n    \n    return time\n\n\n# Passes parameters of angles \nr1 = rplot(30)\nr2 = rplot(45)\nr3 = rplot(60)\nr4 = rplot(70.5)\nr5 = rplot(78)\nr6 = rplot(85)\n\nt = tplot()\n\n\nfig1, ax = plt.subplots()\n\n# Sets the parameters of the plot\nax.set_xlabel(\"Range, r / m\")\nax.set_ylabel(\"Time, t / s\")\nax.set_ylim(0, 30)\nax.set_xlim(0, 2.5)\n\n# Components to be plotted\nax.plot(t, r1, label=\"θ = 30°\")\nax.plot(t, r2, label=\"θ = 45°\")\nax.plot(t, r3, label=\"θ = 60°\")\nax.plot(t, r4, label=\"θ = 70.5°\")\nax.plot(t, r5, label=\"θ = 78°\")\nax.plot(t, r6, label=\"θ = 85°\")\nax.grid()\n\nax.legend()\n\n\n\n\n\n\n\n\n\ndef xplot(a):\n    u = 10\n    g = 10\n\n    arad = (a * np.pi) / 180\n\n    ux = u * np.cos(arad)\n\n    # Creates an empty arrary for the x and y coordinates of the trajectory\n    x = []\n\n    # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n    for i in np.arange(0, 3, 0.01):\n        t = i\n        x.append(ux * t)\n\n    return x\n\n\ndef yplot(a):\n    u = 10\n    g = 10\n    h = 0\n\n    arad = (a * np.pi) / 180\n\n    uy = u * np.sin(arad)\n\n    # Creates an empty arrary for the x and y coordinates of the trajectory\n    y = []\n\n    # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n    for i in np.arange(0, 3, 0.01):\n        t = i\n        T = t * t\n        y.append(h + (uy * t) - (0.5 * g * T))   \n\n    return y    \n\n\nfig2, ax = plt.subplots()\n\n# Passes parameters of angles \nx1 = xplot(30)\nx2 = xplot(45)\nx3 = xplot(60)\nx4 = xplot(70.5)\nx5 = xplot(78)\nx6 = xplot(85)\n\n# Passes parameters of angles \ny1 = yplot(30)\ny2 = yplot(45)\ny3 = yplot(60)\ny4 = yplot(70.5)\ny5 = yplot(78)\ny6 = yplot(85)\n\n\n\n\n\n\n\n\n\n# Components to be plotted\nax.plot(x1, y1, label=\"θ = 30°\")\nax.plot(x2, y2, label=\"θ = 45°\")\nax.plot(x3, y3, label=\"θ = 60°\")\nax.plot(x4, y4, label=\"θ = 70.5°\")\nax.plot(x5, y5, label=\"θ = 78°\")\nax.plot(x6, y6, label=\"θ = 85°\")\nax.grid()\n\n\n# Sets the parameters of the plot\nax.set_xlabel(\"Displacement in x / m\")\nax.set_ylabel(\"Displacement in y / m\")\nax.set_ylim(-5, 5)\nax.set_xlim(0, 15)\n\nax.legend()\n\nplt.show()"
  },
  {
    "objectID": "posts/cchallenge5.html",
    "href": "posts/cchallenge5.html",
    "title": "BPhO Computational Challenge 2024: Challenge 5: Implementing the Bounding Parabola to the Projectile Model",
    "section": "",
    "text": "DISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo .\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\n\n# X = Xtxt.get()\n# Y = Ytxt.get()\n# u = utxt.get()\n\nX = 1000\nY = 300\nu = 150\ng = 9.81\n\nminu = np.sqrt(g) * (np.sqrt(Y + np.sqrt(X**2 + Y**2)))\nmintheta = math.atan((Y + np.sqrt(X**2 + Y**2)) / X)\nminux = minu * np.cos(mintheta)\nminuy = minu * np.sin(mintheta)\nmint = 2 * (minuy / g)\n\nx = []\ny = []\n\nfor i in np.arange(0, mint, 0.01):\n    t = i\n    x.append(minux * t)\n    T = t**2\n    y.append((minuy * t) - (0.5 * g * T))\n    \na = (g / (2 * u**2)) * X**2\nb =  -X\nc = Y + ((g * X**2)/(2 * u**2))\nlow_theta = math.atan((- b - np.sqrt(b**2 - (4 * a * c)))/(2 * a))\nhigh_theta = math.atan((- b + np.sqrt(b**2 - (4 * a * c)))/(2 * a))\n\nlow_ux = u * np.cos(low_theta)\nlow_uy = u * np.sin(low_theta)\nlow_tflight = 2 * (low_uy / g)\n\nlow_x = []\nlow_y = []\n\nfor low_i in np.arange(0, low_tflight, 0.01):\n    low_t = low_i\n    low_x.append(low_ux * low_t)\n    low_T = low_t**2\n    low_y.append((low_uy * low_t) - (0.5 * g * low_T))\n    \nhigh_ux = u * np.cos(high_theta)\nhigh_uy = u * np.sin(high_theta)\nhigh_tflight = 2 * (high_uy / g)\n\nhigh_x = []\nhigh_y = []\n\nfor high_i in np.arange(0, high_tflight, 0.01):\n    high_t = high_i\n    high_x.append(high_ux * high_t)\n    high_T = high_t**2\n    high_y.append((high_uy * high_t) - (0.5 * g * high_T))\n\nu2 = u * u\ntgh = 2 * g\ntghu2 = (tgh) / (u2)\narc = (1 / np.sqrt((2 + tghu2)))\n\nthetamax = np.arcsin(arc)\n\ncosthetamax = np.cos(thetamax)\nsinthetamax = np.sin(thetamax)\n\nmax_ux = u * costhetamax\nmax_uy = u * sinthetamax\nmax_tflight = 2 * (max_uy / g)\n\n# Creates an empty arrary for the x and y coordinates of the trajectory\nmax_x = []\nmax_y = []\n\n# Plots the parabolic path of the projectile with a timestep of 0.01s and an interval of 10s\nfor max_i in np.arange(0, max_tflight, 0.01):\n    max_t = max_i\n    max_x.append(max_ux * max_t)\n    max_T = max_t * max_t\n    max_y.append((max_uy * max_t) - (0.5 * g * max_T))\n    \nmax_range = max_tflight * max_ux\n    \nbounding_a = - (g / (2 * u**2))\nbounding_c = (u**2) / (2 * g)\nbounding_x = np.linspace(0, max_range, 100)\nbounding_y = bounding_a * bounding_x**2 + bounding_c\n\nplt.plot(x, y, label=\"Minimum u\", zorder=1)\nplt.plot(low_x, low_y, label=\"Low Ball\", zorder=2)\nplt.plot(high_x, high_y, label=\"High Ball\", zorder=3)\nplt.plot(bounding_x, bounding_y, label=\"Bounding Parabola\", zorder=4)\nplt.plot(max_x, max_y, label=\"Maximum Range\", zorder=5)\nplt.scatter(X, Y, color=\"red\", marker=\"x\", zorder=6, label=(X,Y))\n\nplt.xlabel(\"Displacement in x / m\")\nplt.ylabel(\"Displacement in y / m\")\nplt.ylim(0)\nplt.xlim(0, max_range)\nplt.grid()\nplt.legend(loc=\"upper right\")\n\n\nplt.show()"
  },
  {
    "objectID": "posts/cchallenge9.html",
    "href": "posts/cchallenge9.html",
    "title": "BPhO Computational Challenge 2024: Challenge 9: Creating a Projectile Model Incorporating Air Resistance",
    "section": "",
    "text": "DISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo ."
  },
  {
    "objectID": "posts/cchallenge4.html",
    "href": "posts/cchallenge4.html",
    "title": "BPhO Computational Challenge 2024: Challenge 4: Creating a Simple Analytical Drag-Free Projectile Model",
    "section": "",
    "text": "DISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo ."
  },
  {
    "objectID": "posts/cchallenge.html",
    "href": "posts/cchallenge.html",
    "title": "BPhO Computational Challenge: Challenges 1 & 2 2024: Creating a Simple Analytical Drag-Free Projectile Model",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np\nimport math\nimport customtkinter\nfrom customtkinter import *\nfrom tkinter import *\nfrom matplotlib.figure import Figure \nfrom matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg,  \nNavigationToolbar2Tk)\nimport matplotlib.animation as animation\nfrom PIL import Image, ImageTk\nimport os\n\n# Defines parameters of the app\napp = CTk()\napp.geometry(\"1500x825\")\napp.title(\"BPhO Computational Challenge App\")\n\n# Determines which challenge has been selected\ndef chal_picker(challenge):\n    def menu_delete():\n        image_label.destroy()\n        chal_combo.destroy()\n    \n    menu_delete()\n\n    # Restores to base\n    def delete():\n        frame1.destroy()\n        frame2.destroy()\n        frame3.destroy()\n        frame4.destroy()\n        label10.destroy()\n\n        main_menu()\n\n    # Determines a value for g based on the result of the combobox\n    def g_picker(choice):\n        global pre_g\n        if choice == \"Mercury\":\n            pre_g = 3.61\n        elif choice == \"Venus\":\n            pre_g = 8.83\n        elif choice == \"Earth\":\n            pre_g = 9.81\n        elif choice == \"Mars\":\n            pre_g = 3.75\n        elif choice == \"Jupiter\":\n            pre_g = 26.0\n        elif choice == \"Saturn\":\n            pre_g = 11.2\n        elif choice == \"Uranus\":\n            pre_g = 10.5\n        elif choice == \"Neptune\":\n            pre_g = 13.3\n        elif choice == \"Pluto\":\n            pre_g = 0.61\n        elif choice == \"Sun\":\n            pre_g = 274.0\n        elif choice == \"Moon\":\n            pre_g = 1.625\n    \n    if challenge == \"Challenge 1 & 2\":\n        # Defines parameters of frame1\n        frame1 = CTkFrame(master=app, border_width=2, width=250, height=375)\n        frame1.pack(anchor=\"nw\", expand=True, padx=20, pady=67)\n\n        # Defines parameters of frame2\n        frame2 = CTkFrame(master=app, border_width=2, width=250, height=250)\n        frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n        frame2.place(relx=0.014, rely=0.655)\n        \n        # Defines parameters of frame3\n        frame3 = CTkFrame(master=app, border_width=2, height=725, width=1025)\n        frame3.pack(anchor=\"n\", expand=True, padx=20)\n        frame3.place(relx=0.1875, rely=0.08)\n        \n        # Defines parameters of frame4\n        frame4 = CTkFrame(master=app, border_width=2, height=250, width=175)\n        frame4.pack(anchor=\"n\", expand=True, padx=20)\n        frame4.place(relx=0.875, rely=0.08)\n                \n        # Creates a reset button\n        del_btn = CTkButton(master=frame4, text=\"RETURN TO HOME\", command=delete, width=100, height=30)\n        del_btn.pack(anchor=\"n\")\n        del_btn.place(relx=0.175, rely=0.075)\n\n        # Function that occurs when the submit button is pressed\n        def click_handler():\n            # Defines parameters of frame2\n            frame2 = CTkFrame(master=app, border_width=2, width=250, height=250)\n            frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n            frame2.place(relx=0.014, rely=0.655)\n\n            # Creates the label for the calculated values frame\n            label2 = CTkLabel(master=frame2, text=\"Calculated Values:\")\n            label2.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n            label2.place(relx=0.3, rely=0.05)\n            \n            # Takes parameters u, angle and h from input text fields\n            u = utxt.get()\n            angle = atxt.get()\n            h = htxt.get()\n            \n            # If statement to determine what value of g should be used\n            if gtxt.get() != \"\":\n                 g=gtxt.get()\n                 g=float(g.rstrip(\"\\n\"))\n            else:\n                g=pre_g\n            \n            # Strips the text to remove blank spaces\n            angle=float(angle.rstrip(\"\\n\"))\n            h=float(h.rstrip(\"\\n\"))\n            u=float(u.rstrip(\"\\n\"))\n            \n            # Converts the angle to radians\n            theta = (angle * np.pi) / 180\n\n            # Resloves forces into horizontal and vertical component\n            costheta = math.cos(theta)\n            sintheta = math.sin(theta)\n\n            ux = u * costheta\n            uy = u * sintheta\n            \n            # Calculates the range and time of flight of the projectile\n            R = (u**2 / g) * (sintheta*costheta+costheta*math.sqrt(sintheta**2 + ((2 * g * h) / (u**2))))\n            tflight = R / (u * costheta)\n\n            # Creates an empty arrary for the x and y coordinates of the trajectory\n            x = []\n            y = []\n\n            # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n            for i in np.arange(0, tflight, 0.01):\n                t = i\n                x.append(ux * t)\n                T = t * t\n                y.append(h + (uy * t) - (0.5 * g * T))            \n\n            # Apogee calculation\n            apy = (0 - (uy*uy)) / (2 * g * -1) + h\n            y_graph = apy + 5\n            tflight0 = 2 * uy / g\n            apx = (ux * tflight0) / 2\n            \n            # Generates the calculated values text\n            # Time of flight phrase\n            tflightph = \"Time of flight: \" + str(round(tflight, 2)) + \" s\"\n            label5 = CTkLabel(master=frame2, text=tflightph)\n            label5.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label5.place(relx=0.27, rely=0.2)\n                \n            # Range phrase\n            travel = \"Range: \" + str(round(R, 2)) + \" m\"    \n            label6 = CTkLabel(master=frame2, text=travel)\n            label6.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label6.place(relx=0.31, rely=0.35)\n\n            # Creates the figure\n            fig, ax = plt.subplots()\n\n            # Sets the parameters of the plot\n            ax.set_xlabel(\"Displacement in x / m\")\n            ax.set_ylabel(\"Displacement in y / m\")\n            ax.set_ylim(0, y_graph)\n            ax.set_xlim(0, R)\n\n            # Components to be plotted\n            ax.plot(x, y)\n            ax.grid()\n            ax.scatter(apx, apy)\n            \n            # Creates a canvas in the app for the plot to appear\n            canvas = FigureCanvasTkAgg(fig,master=frame3)\n            canvas.get_tk_widget().place(relx=0.012, rely=0.013, height=700, width=1000)\n            canvas.draw()\n\n            # Saves an image png of the figure when a button is pressed\n            def image_handler():\n                path=\"/Users/Mark Watson/Desktop/Python Projects/BPHO/Projectiles\"\n                os.chdir(path)\n                fig.savefig(fname='Challenge1&2.png', dpi='figure', format='png')\n            \n            # Creates a save button for png image\n            img_btn = CTkButton(master=frame4, text=\"SAVE AS PNG\", command=image_handler, width=100, height=30)\n            img_btn.pack(anchor=\"n\")\n            img_btn.place(relx=0.23, rely=0.3)\n\n        # Creates title label\n        label10 = CTkLabel(master=app, text=\"Challenge 1 & 2: Custom Projectile\", font=(\"Helvetica\", 40))\n        label10.pack(anchor=\"s\", expand=True, padx=10)\n        label10.place(relx=0.3, rely=0.02)\n\n        # Creates the label for the parameters frame\n        label1 = CTkLabel(master=frame1, text=\"Enter Parameters Below:\")\n        label1.pack(anchor=\"s\", expand=True, pady=10, padx=30)\n        label1.place(relx=0.22, rely=0.05)\n\n        # Creates the label for the calculated values frame\n        label2 = CTkLabel(master=frame2, text=\"Calculated Values:\")\n        label2.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n        label2.place(relx=0.3, rely=0.05)\n\n        # Creates input text fields for the parameters\n        # Initial velocity field\n        utxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Initial velocity in ms⁻¹\")\n        utxt.place(relx=0.5, rely=0.15, anchor=\"n\")\n\n        # Angle field\n        atxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Angle in °\")\n        atxt.place(relx=0.5, rely=0.25, anchor=\"n\")\n\n        # Initial height field\n        htxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Height in m\")\n        htxt.place(relx=0.5, rely=0.35, anchor=\"n\")\n\n        # Creates a submission button\n        btn = CTkButton(master=frame1, text=\"Submit\", command=click_handler, width=100, height=30)\n        btn.pack(anchor=\"n\")\n        btn.place(relx=0.3, rely=0.75)\n\n        # Creates a label for values of g\n        label3 = CTkLabel(master=frame1, text=\"Set a prefab or custom value for g:\")\n        label3.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n        label3.place(relx=0.11, rely=0.45)\n\n        # Creates input text field for a custom value of g\n        gtxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Custom value for g\")\n        gtxt.place(relx=0.5, rely=0.65, anchor=\"n\")\n\n        # Array of popular objects to obtain a prefab value for g\n        objects = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\", \"Sun\", \"Moon\"]\n        # Creates a combobox to select a prefab value for g\n        combo = CTkComboBox(master=frame1, width=200, height=20, values=objects, command=g_picker, state=\"readonly\")\n        combo.place(relx=0.5, rely=0.55, anchor=\"n\")\n        combo.set(\"Use a prefab value for g\")\n        \n    elif challenge == \"Challenge 3\":\n        # Restores to base\n        def delete3():\n            frame1.destroy()\n            frame3.destroy()\n            frame4.destroy()\n            label10.destroy()\n\n            main_menu()\n\n        # Defines parameters of frame1\n        frame1 = CTkFrame(master=app, border_width=2, width=250, height=375)\n        frame1.pack(anchor=\"nw\", expand=True, padx=20, pady=67)\n\n        # Defines parameters of frame2\n        frame2 = CTkFrame(master=app, width=250, height=250, fg_color=\"#eeeeee\")\n        frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n        frame2.place(relx=0.014, rely=0.655)\n        \n        # Defines parameters of frame3\n        frame3 = CTkFrame(master=app, border_width=2, height=725, width=1025)\n        frame3.pack(anchor=\"n\", expand=True, padx=20)\n        frame3.place(relx=0.1875, rely=0.08)\n        \n        # Defines parameters of frame4\n        frame4 = CTkFrame(master=app, border_width=2, height=250, width=175)\n        frame4.pack(anchor=\"n\", expand=True, padx=20)\n        frame4.place(relx=0.875, rely=0.08)\n        \n        # Creates a reset button\n        del_btn = CTkButton(master=frame4, text=\"RETURN TO HOME\", command=delete3, width=100, height=30)\n        del_btn.pack(anchor=\"n\")\n        del_btn.place(relx=0.175, rely=0.075)\n            \n        # Saves an image png of the figure when a button is pressed\n        def image_handler():\n            # Changes the path to the working directory of the project\n            path=\"/Users/Mark Watson/Desktop/Python Projects/BPHO/Projectiles\"\n            os.chdir(path)\n            plt.savefig(fname='Challenge3.png', dpi='figure',format='png')\n            \n        def click_handler():\n            # Retrieves parameters from input fields\n            X = Xtxt.get()\n            Y = Ytxt.get()\n            u = utxt.get()\n            \n            # Strips retrieved input\n            X=float(X.rstrip(\"\\n\"))\n            Y=float(Y.rstrip(\"\\n\"))\n            u=float(u.rstrip(\"\\n\"))\n            \n            # If statement to determine what value of g should be used\n            if gtxt.get() != \"\":\n                 g=gtxt.get()\n                 g=float(g.rstrip(\"\\n\"))\n            else:\n                g=pre_g\n                \n            # Calculation of the minimum values of velocity, horizontal velocity, vertical velocity and angle\n            minu = math.sqrt(g) * (math.sqrt(Y + math.sqrt(X**2 + Y**2)))\n            mintheta = math.atan((Y + math.sqrt(X**2 + Y**2)) / X)\n            minux = minu * np.cos(mintheta)\n            minuy = minu * np.sin(mintheta)\n            mint = (X / minux) + 1\n\n            # Creates an empty array of x and y coordinates\n            x = []\n            y = []\n\n            # For loop to plot the trajectory of the projectile\n            for i in np.arange(0, mint, 0.01):\n                t = i\n                x.append(minux * t)\n                T = t**2\n                y.append((minuy * t) - (0.5 * g * T))\n                \n            a = (g / (2 * u**2)) * X**2\n            b =  -X\n            c = Y + ((g * X**2)/(2 * u**2))\n            \n            # Calculates angles of projection for both the high and low ball trajectories\n            low_theta = math.atan((- b - math.sqrt(b**2 - (4 * a * c)))/(2 * a))\n            high_theta = math.atan((- b + math.sqrt(b**2 - (4 * a * c)))/(2 * a))\n\n            # Calculates values for the low ball trajectory\n            low_ux = u * np.cos(low_theta)\n            low_uy = u * np.sin(low_theta)\n            low_tflight = (X / low_ux) + 1\n            \n            # Creates empty arrays of x and y coordinates for low ball\n            low_x = []\n            low_y = []\n\n            # For loop to plot the trajectory of the low ball\n            for low_i in np.arange(0, low_tflight, 0.01):\n                low_t = low_i\n                low_x.append(low_ux * low_t)\n                low_T = low_t**2\n                low_y.append((low_uy * low_t) - (0.5 * g * low_T))\n            \n            # Calculates values for the high ball trajectory\n            high_ux = u * np.cos(high_theta)\n            high_uy = u * np.sin(high_theta)\n            high_tflight = (X / high_ux) + 1\n\n            # Empty arrays for the high ball trajectories\n            high_x = []\n            high_y = []\n\n            # Plots high ball trajectories\n            for high_i in np.arange(0, high_tflight, 0.01):\n                high_t = high_i\n                # Adds x coordinate to the array\n                high_x.append(high_ux * high_t)\n                high_T = high_t**2\n                # Adds y coordinate to the arrray\n                high_y.append((high_uy * high_t) - (0.5 * g * high_T))\n\n            # Creates figure\n            fig, ax = plt.subplots()\n            \n            # Plots the graph with minimum u, low ball and high ball trajectories\n            ax.plot(x, y, label=\"Minimum u\")\n            ax.plot(low_x, low_y, label=\"Low ball\")\n            ax.plot(high_x, high_y, label=\"High ball\")\n            \n            # Scatter to show the user's chosen point\n            ax.scatter(X, Y, marker=\"x\", color=\"red\")\n            \n            # Sets some parameters of the plot\n            ax.grid()\n            ax.set_xlabel(\"Displacement in x / m\")\n            ax.set_ylabel(\"Displacement in y / m\")\n            ax.set_ylim(0)\n            ax.set_xlim(0, X)\n            ax.legend()\n\n            # Creates a canvas in the app for the plot to appear\n            canvas = FigureCanvasTkAgg(fig,master=frame3)\n            canvas.get_tk_widget().place(relx=0.012, rely=0.013, height=700, width=1000)\n            canvas.draw()\n            \n            # Creates a save button for png image\n            img_btn = CTkButton(master=frame4, text=\"SAVE AS PNG\", command=image_handler, width=100, height=30)\n            img_btn.pack(anchor=\"n\")\n            img_btn.place(relx=0.23, rely=0.3)\n\n        # Creates title label for the plot\n        label10 = CTkLabel(master=app, text=\"Challenge 3: Minimum u, Low Ball & High Ball\", font=(\"Helvetica\", 40))\n        label10.pack(anchor=\"s\", expand=True, padx=10)\n        label10.place(relx=0.275, rely=0.02)\n\n        # Label showing the user where to enter parameters for the plot\n        label1 = CTkLabel(master=frame1, text=\"Enter Parameters Below:\")\n        label1.pack(anchor=\"s\", expand=True, pady=10, padx=30)\n        label1.place(relx=0.22, rely=0.05)\n\n        # Text field to input initial velocity\n        utxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Initial velocity in ms⁻¹\")\n        utxt.place(relx=0.5, rely=0.15, anchor=\"n\")\n\n        # Text field to input an x coordinate\n        Xtxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"x coordinate\")\n        Xtxt.place(relx=0.5, rely=0.25, anchor=\"n\")\n\n        # Text field to input a y coordinate\n        Ytxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"y coordinate\")\n        Ytxt.place(relx=0.5, rely=0.35, anchor=\"n\")\n\n        # Creates a submit button\n        btn = CTkButton(master=frame1, text=\"Submit\", command=click_handler, width=100, height=30)\n        btn.pack(anchor=\"n\")\n        btn.place(relx=0.3, rely=0.75)\n        \n        # Creates a label for values of g\n        label3 = CTkLabel(master=frame1, text=\"Set a prefab or custom value for g:\")\n        label3.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n        label3.place(relx=0.11, rely=0.45)\n\n        # Creates input text field for a custom value of g\n        gtxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Custom value for g\")\n        gtxt.place(relx=0.5, rely=0.65, anchor=\"n\")\n\n        # Array of popular objects to obtain a prefab value for g\n        objects = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\", \"Sun\", \"Moon\"]\n        # Creates a combobox to select a prefab value for g\n        combo = CTkComboBox(master=frame1, width=200, height=20, values=objects, command=g_picker, state=\"readonly\")\n        combo.place(relx=0.5, rely=0.55, anchor=\"n\")\n        combo.set(\"Use a prefab value for g\")\n        \n    elif  challenge == \"Challenge 4\":\n        # Defines parameters of frame1\n        frame1 = CTkFrame(master=app, border_width=2, width=250, height=375)\n        frame1.pack(anchor=\"nw\", expand=True, padx=20, pady=67)\n        \n        # Defines parameters of frame2\n        frame2 = CTkFrame(master=app, border_width=2, width=250, height=250)\n        frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n        frame2.place(relx=0.014, rely=0.655)\n        \n        # Defines parameters of frame3\n        frame3 = CTkFrame(master=app, border_width=2, height=725, width=1025)\n        frame3.pack(anchor=\"n\", expand=True, padx=20)\n        frame3.place(relx=0.1875, rely=0.08)\n        \n        # Defines parameters of frame4\n        frame4 = CTkFrame(master=app, border_width=2, height=250, width=175)\n        frame4.pack(anchor=\"n\", expand=True, padx=20)\n        frame4.place(relx=0.875, rely=0.08)\n                \n        # Creates a reset button\n        del_btn = CTkButton(master=frame4, text=\"RETURN TO HOME\", command=delete, width=100, height=30)\n        del_btn.pack(anchor=\"n\")\n        del_btn.place(relx=0.175, rely=0.075)\n            \n        # Saves an image png of the figure when a button is pressed\n        def image_handler():\n            path=\"/Users/Mark Watson/Desktop/Python Projects/BPHO/Projectiles\"\n            os.chdir(path)\n            plt.savefig(fname=\"Challenge4.png\",dpi=\"figure\", format='png')\n        \n        def click_handler():\n            # Defines parameters of frame2\n            frame2 = CTkFrame(master=app, border_width=2, width=250, height=250)\n            frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n            frame2.place(relx=0.014, rely=0.655)\n\n            # Creates the label for the calculated values frame\n            label2 = CTkLabel(master=frame2, text=\"Calculated Values:\")\n            label2.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n            label2.place(relx=0.3, rely=0.05)\n\n            # Retrieves parameters of the plot\n            u = utxt.get()\n            angle = atxt.get()\n            h = htxt.get()\n            \n            # Strips the retrieved data for further use\n            angle=float(angle.rstrip(\"\\n\"))\n            h=float(h.rstrip(\"\\n\"))\n            u=float(u.rstrip(\"\\n\"))\n            \n            # If statement to determine what value of g should be used\n            if gtxt.get() != \"\":\n                 g=gtxt.get()\n                 g=float(g.rstrip(\"\\n\"))\n            else:\n                g=pre_g\n            \n            # Produces an error if the height is less than 0\n            if h &lt; 0:\n                exit()\n\n            # Converts angle entered in degress to radians\n            theta = (angle * np.pi) / 180\n\n            # Resloves forces into horizontal and vertical component\n            costheta = math.cos(theta)\n            sintheta = math.sin(theta)\n\n            ux = u * costheta\n            uy = u * sintheta\n            \n            # Calculates the range and time of flight of the projectile\n            R = (u**2 / g) * (sintheta*costheta+costheta*math.sqrt(sintheta**2 + ((2 * g * h) / (u**2))))\n            tflight = R / (u * costheta)\n\n            # Creates the figure\n            fig, ax = plt.subplots()\n\n            # Creates an empty arrary for the x and y coordinates of the trajectory\n            x = []\n            y = []\n\n            # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n            for i in np.arange(0, tflight, 0.01):\n                t = i\n                x.append(ux * t)\n                T = t * t\n                y.append(h + (uy * t) - (0.5 * g * T))            \n\n            # Apogee calculation\n            apy = (0 - (uy*uy)) / (2 * g * -1) + h\n            tflight0 = 2 * uy / g\n            apx = (ux * tflight0) / 2\n            \n            # Generates the calculated values text\n            # Time of flight phrase\n            tflightph = \"T=\" + str(round(tflight, 2)) + \" s\"\n            label3 = CTkLabel(master=frame2, text=tflightph)\n            label3.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label3.place(x=96, y=40)\n                \n            # Range phrase\n            travel = \"R=\" + str(round(R, 2)) + \" m\"    \n            label4 = CTkLabel(master=frame2, text=travel)\n            label4.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label4.place(x=88, y=80)\n            \n            # Calculations for the trajectory that maximises range\n            u2 = u * u\n            tgh = 2 * g * h\n            tghu2 = (tgh) / (u2)\n            arc = (1 / (math.sqrt(2 + tghu2)))\n            \n            thetamax = np.arcsin(arc)\n            \n            max_ux = u * math.cos(thetamax)\n            max_uy = u * math.sin(thetamax)\n            \n            # Creates an empty arrary for the x and y coordinates of the trajectory\n            max_x = []\n            max_y = []\n\n            # Calculates the range and time of flight of the projectile\n            max_R = (u**2 / g) * math.sqrt(1 + (2 * g * h/ u**2))\n            max_tflight = max_R / max_ux\n\n            # Plots the parabolic path of the projectile with a timestep of 0.01s and an interval of 10s\n            for max_i in np.arange(0, max_tflight, 0.01):\n                max_t = max_i\n                max_x.append(max_ux * max_t)\n                max_T = max_t * max_t\n                max_y.append(h + (max_uy * max_t) - (0.5 * g * max_T))\n                \n            # Apogee calculation\n            max_apy = (0 - (max_uy*max_uy)) / (2 * g * -1) + h\n\n            # Compares the y values of the two apogees\n            def compapy(apy, max_apy):\n                if apy &gt; max_apy:\n                    return apy\n                else:\n                    return max_apy\n            y_graph = compapy(apy, max_apy) * 1.1 \n            \n            # Generates the calculated values text\n            # Time of flight phrase\n            tflightph = \"Tₘₐₓ=\" + str(round(max_tflight, 2)) + \" s\"\n            label5 = CTkLabel(master=frame2, text=tflightph)\n            label5.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label5.place(x=86, y=60)\n                \n            # Range phrase\n            travel = \"Rₘₐₓ= \" + str(round(max_R, 2)) + \" m\"    \n            label6 = CTkLabel(master=frame2, text=travel)\n            label6.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label6.place(x=80, y=100)\n\n            #Time of flight calculation\n            max_tflighta = 2 * max_uy / g\n            max_apx = (max_ux * max_tflighta) / 2\n\n            # Sets parameters of the plot\n            ax.set_xlabel(\"Displacement in x / m\")\n            ax.set_ylabel(\"Displacement in y / m\")\n            ax.set_ylim(0, y_graph)\n            ax.set_xlim(0, max_R)\n            \n            # Creates the figure\n            fig1, = ax.plot(x, y, color=\"blue\", label=\"Custom Projectile\")\n            # Plots the graph\n            ax.plot(max_x, max_y, color=\"orange\", label=\"Maximum Range Projectile\")\n            # Plots scatters showing the apogees of the trajectories\n            ax.scatter(apx, apy, color=\"blue\")\n            ax.scatter(max_apx, max_apy, color=\"orange\")\n            ax.grid()\n            \n            ax.legend(loc=\"upper right\")\n            \n            # Creates a canvas in the app for the plot to appear\n            canvas = FigureCanvasTkAgg(fig,master=frame3)\n            canvas.get_tk_widget().place(relx=0.012, rely=0.013, height=700, width=1000)\n            canvas.draw()\n            \n            # Creates a save button for png image\n            img_btn = CTkButton(master=frame4, text=\"SAVE AS PNG\", command=image_handler, width=100, height=30)\n            img_btn.pack(anchor=\"n\")\n            img_btn.place(relx=0.23, rely=0.3)\n\n        # Creates title label for the graph\n        label10 = CTkLabel(master=app, text=\"Challenge 4: Custom Projectile vs Maximum Horizontal Range\", font=(\"Helvetica\", 40))\n        label10.pack(anchor=\"s\", expand=True, padx=10)\n        label10.place(relx=0.14, rely=0.02)\n\n        # Creates the label for the parameters frame\n        label1 = CTkLabel(master=frame1, text=\"Enter Parameters Below:\")\n        label1.pack(anchor=\"s\", expand=True, pady=10, padx=30)\n        label1.place(relx=0.22, rely=0.05)\n\n        # Creates the label for the calculated valeues frame\n        label2 = CTkLabel(master=frame2, text=\"Calculated Values:\")\n        label2.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n        label2.place(relx=0.3, rely=0.05)\n\n        # Creates input text fields for the parameters\n        # Initial velocity field\n        utxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Initial velocity in ms⁻¹\")\n        utxt.place(relx=0.5, rely=0.15, anchor=\"n\")\n\n        # Angle field\n        atxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Angle in °\")\n        atxt.place(relx=0.5, rely=0.25, anchor=\"n\")\n\n        # Initial height field\n        htxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Height in m\")\n        htxt.place(relx=0.5, rely=0.35, anchor=\"n\")\n\n        # Creates a submission button\n        btn = CTkButton(master=frame1, text=\"Submit\", command=click_handler, width=100, height=30)\n        btn.pack(anchor=\"n\")\n        btn.place(relx=0.3, rely=0.75)\n\n        # Creates a label for values of g\n        label3 = CTkLabel(master=frame1, text=\"Set a prefab or custom value for g:\")\n        label3.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n        label3.place(relx=0.11, rely=0.45)\n\n        # Creates input text field for a custom value of g\n        gtxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Custom value for g\")\n        gtxt.place(relx=0.5, rely=0.65, anchor=\"n\")\n\n        # Array of popular objects to obtain a prefab value for g\n        objects = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\", \"Sun\", \"Moon\"]\n        # Creates a combobox to select a prefab value for g\n        combo = CTkComboBox(master=frame1, width=200, height=20, values=objects, command=g_picker, state=\"readonly\")\n        combo.place(relx=0.5, rely=0.55, anchor=\"n\")\n        combo.set(\"Use a prefab value for g\")\n    \n    elif challenge == \"Challenge 5\":\n        # Restores to base\n        def delete5():\n            frame1.destroy()\n            frame3.destroy()\n            frame4.destroy()\n            label10.destroy()\n\n            main_menu()\n  \n        # Saves an image png of the figure when a button is pressed\n        def image_handler():\n            path=\"/Users/Mark Watson/Desktop/Python Projects/BPHO/Projectiles\"\n            os.chdir(path)\n            plt.savefig(fname=\"Challenge5\",dpi=\"figure\", format='png')\n\n        # Defines parameters of frame1\n        frame1 = CTkFrame(master=app, border_width=2, width=250, height=375)\n        frame1.pack(anchor=\"nw\", expand=True, padx=20, pady=67)\n\n        # Defines parameters of frame2\n        frame2 = CTkFrame(master=app, width=250, height=250, fg_color=\"#eeeeee\")\n        frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n        frame2.place(relx=0.014, rely=0.655)\n\n        # Defines parameters of frame3\n        frame3 = CTkFrame(master=app, border_width=2, height=725, width=1025)\n        frame3.pack(anchor=\"n\", expand=True, padx=20)\n        frame3.place(relx=0.1875, rely=0.08)\n        \n        # Defines parameters of frame4\n        frame4 = CTkFrame(master=app, border_width=2, height=250, width=175)\n        frame4.pack(anchor=\"n\", expand=True, padx=20)\n        frame4.place(relx=0.875, rely=0.08)\n                \n        # Creates a reset button\n        del_btn = CTkButton(master=frame4, text=\"RETURN TO HOME\", command=delete5, width=100, height=30)\n        del_btn.pack(anchor=\"n\")\n        del_btn.place(relx=0.175, rely=0.075)\n        \n        def click_handler2():\n            # Retrieves paramaters from input text fields\n            X = Xtxt.get()\n            Y = Ytxt.get()\n            u = utxt.get()\n            \n            # Strips the inputs so the data can be used further\n            X=float(X.rstrip(\"\\n\"))\n            Y=float(Y.rstrip(\"\\n\"))\n            u=float(u.rstrip(\"\\n\"))\n            \n            # If statement to determine what value of g should be used\n            if gtxt.get() != \"\":\n                 g=gtxt.get()\n                 g=float(g.rstrip(\"\\n\"))\n            else:\n                g=pre_g\n\n            # Calculates minimum values of the plot\n            minu = math.sqrt(g) * (math.sqrt(Y + math.sqrt(X**2 + Y**2)))\n            mintheta = math.atan((Y + math.sqrt(X**2 + Y**2)) / X)\n            minux = minu * np.cos(mintheta)\n            minuy = minu * np.sin(mintheta)\n            mint = 2 * (minuy / g)\n\n            # Empty array of x and y coordinates\n            x = []\n            y = []\n\n            # For loop to plot the minimum u trajectory\n            for i in np.arange(0, mint, 0.01):\n                t = i\n                x.append(minux * t)\n                T = t**2\n                y.append((minuy * t) - (0.5 * g * T))\n                \n            a = (g / (2 * u**2)) * X**2\n            b =  -X\n            c = Y + ((g * X**2)/(2 * u**2))\n\n            # Calculates angle of projection for low and high ball trajectories\n            low_theta = math.atan((- b - math.sqrt(b**2 - (4 * a * c)))/(2 * a))\n            high_theta = math.atan((- b + math.sqrt(b**2 - (4 * a * c)))/(2 * a))\n\n            # Calculates parameters for the low ball trajectory\n            low_ux = u * np.cos(low_theta)\n            low_uy = u * np.sin(low_theta)\n            low_tflight = 2 * (low_uy / g)\n\n            # Empty array of x and y coordinates for the low ball trajectory\n            low_x = []\n            low_y = []\n\n            # For loop to plot the trajecetory of the low ball\n            for low_i in np.arange(0, low_tflight, 0.01):\n                low_t = low_i\n                low_x.append(low_ux * low_t)\n                low_T = low_t**2\n                low_y.append((low_uy * low_t) - (0.5 * g * low_T))\n            \n            # Calculates high ball parameters\n            high_ux = u * np.cos(high_theta)\n            high_uy = u * np.sin(high_theta)\n            high_tflight = 2 * (high_uy / g)\n\n            # Empty array of x and y coordinates for the low ball trajectory\n            high_x = []\n            high_y = []\n\n            # Calculates high ball parameters\n            for high_i in np.arange(0, high_tflight, 0.01):\n                high_t = high_i\n                high_x.append(high_ux * high_t)\n                high_T = high_t**2\n                high_y.append((high_uy * high_t) - (0.5 * g * high_T))\n\n            # Calculations for the maximum range projectile\n            u2 = u * u\n            tgh = 2 * g\n            tghu2 = (tgh) / (u2)\n            arc = (1 / math.sqrt((2 + tghu2)))\n\n            thetamax = np.arcsin(arc)\n\n            costhetamax = math.cos(thetamax)\n            sinthetamax = math.sin(thetamax)\n\n            max_ux = u * costhetamax\n            max_uy = u * sinthetamax\n            max_tflight = 2 * (max_uy / g)\n\n            # Creates an empty arrary for the x and y coordinates of the trajectory\n            max_x = []\n            max_y = []\n\n            # Plots the trajectory of the maximum range projectile\n            for max_i in np.arange(0, max_tflight, 0.01):\n                max_t = max_i\n                max_x.append(max_ux * max_t)\n                max_T = max_t * max_t\n                max_y.append((max_uy * max_t) - (0.5 * g * max_T))\n                \n            max_range = max_tflight * max_ux\n            \n            # Adds bounding parabola\n            bounding_a = - (g / (2 * u**2))\n            bounding_c = (u**2) / (2 * g)\n            bounding_x = np.linspace(0, max_range, 100)\n            bounding_y = bounding_a * bounding_x**2 + bounding_c\n\n            # Creates figure\n            fig, ax = plt.subplots()\n\n            # Plots the curves and the user's chosen x and y coordinate\n            ax.plot(x, y, label=\"Minimum u\", zorder=1)\n            ax.plot(low_x, low_y, label=\"Low Ball\", zorder=2)\n            ax.plot(high_x, high_y, label=\"High Ball\", zorder=3)\n            ax.plot(bounding_x, bounding_y, label=\"Bounding Parabola\", zorder=4)\n            ax.plot(max_x, max_y, label=\"Maximum Range\", zorder=5)\n            ax.scatter(X, Y, color=\"red\", marker=\"x\", zorder=6, label=(X,Y))\n\n            # Sets parameters of the plot\n            ax.set_xlabel(\"Displacement in x / m\")\n            ax.set_ylabel(\"Displacement in y / m\")\n            ax.set_ylim(0)\n            ax.grid()\n            ax.legend(loc=\"upper right\")\n\n            ax.set_xlim(0, max_range)\n            \n            # Displays the graph in the UI\n            canvas = FigureCanvasTkAgg(fig,master=frame3)\n            canvas.draw()\n            canvas.get_tk_widget().place(relx=0.012, rely=0.013, height=700, width=1000)\n            \n            # Creates a save button for png image\n            img_btn = CTkButton(master=frame4, text=\"SAVE AS PNG\", command=image_handler, width=100, height=30)\n            img_btn.pack(anchor=\"n\")\n            img_btn.place(relx=0.23, rely=0.3)\n\n        # Creates title label for the graph\n        label10 = CTkLabel(master=app, text=\"Challenge 5: Adding the Bounding Parabola & Maximum Horizontal Range\", font=(\"Helvetica\", 40))\n        label10.pack(anchor=\"s\", expand=True, padx=10)\n        label10.place(relx=0.065, rely=0.02)    \n        \n        # Creates label to show where the user should input parameters\n        label1 = CTkLabel(master=frame1, text=\"Enter Parameters Below:\")\n        label1.pack(anchor=\"s\", expand=True, pady=10, padx=30)\n        label1.place(relx=0.22, rely=0.05)\n\n        # Creates text input fields for initial velocity, x coorindate, y coordinate\n        utxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Initial velocity in ms⁻¹\")\n        utxt.place(relx=0.5, rely=0.15, anchor=\"n\")\n\n        Xtxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"x coordinate\")\n        Xtxt.place(relx=0.5, rely=0.25, anchor=\"n\")\n\n        Ytxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"y coordinate\")\n        Ytxt.place(relx=0.5, rely=0.35, anchor=\"n\")\n\n        # Creates submission button\n        btn = CTkButton(master=frame1, text=\"Submit\", command=click_handler2, width=100, height=30)\n        btn.pack(anchor=\"n\")\n        btn.place(relx=0.3, rely=0.75)\n        \n        # Creates a label for values of g\n        label3 = CTkLabel(master=frame1, text=\"Set a prefab or custom value for g:\")\n        label3.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n        label3.place(relx=0.11, rely=0.45)\n\n        # Creates input text field for a custom value of g\n        gtxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Custom value for g\")\n        gtxt.place(relx=0.5, rely=0.65, anchor=\"n\")\n\n        # Array of popular objects to obtain a prefab value for g\n        objects = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\", \"Sun\", \"Moon\"]\n        # Creates a combobox to select a prefab value for g\n        combo = CTkComboBox(master=frame1, width=200, height=20, values=objects, command=g_picker, state=\"readonly\")\n        combo.place(relx=0.5, rely=0.55, anchor=\"n\")\n        combo.set(\"Use a prefab value for g\")\n\n    elif challenge == \"Challenge 6\":\n        # Defines parameters of frame1\n        frame1 = CTkFrame(master=app, border_width=2, width=250, height=375)\n        frame1.pack(anchor=\"nw\", expand=True, padx=20, pady=67)\n\n        # Defines parameters of frame2\n        frame2 = CTkFrame(master=app, border_width=2, width=250, height=250)\n        frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n        frame2.place(relx=0.014, rely=0.655)\n        \n        # Defines parameters of frame3\n        frame3 = CTkFrame(master=app, border_width=2, height=725, width=1025)\n        frame3.pack(anchor=\"n\", expand=True, padx=20)\n        frame3.place(relx=0.1875, rely=0.08)\n        \n        # Defines parameters of frame4\n        frame4 = CTkFrame(master=app, border_width=2, height=250, width=175)\n        frame4.pack(anchor=\"n\", expand=True, padx=20)\n        frame4.place(relx=0.875, rely=0.08)\n                \n        # Creates a reset button\n        del_btn = CTkButton(master=frame4, text=\"RETURN TO HOME\", command=delete, width=100, height=30)\n        del_btn.pack(anchor=\"n\")\n        del_btn.place(relx=0.175, rely=0.075)\n            \n        # Saves an image png of the figure when a button is pressed\n        def image_handler():\n            path=\"/Users/Mark Watson/Desktop/Python Projects/BPHO/Projectiles\"\n            os.chdir(path)\n            plt.savefig(fname=\"Challenge6.png\",dpi=\"figure\", format='png')\n        \n        def click_handler():\n            # Defines parameters of frame2\n            frame2 = CTkFrame(master=app, border_width=2, width=250, height=250)\n            frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n            frame2.place(relx=0.014, rely=0.655)\n\n            # Creates the label for the calculated values frame\n            label2 = CTkLabel(master=frame2, text=\"Calculated Values:\")\n            label2.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n            label2.place(relx=0.3, rely=0.05)\n\n            # Retrieve parameters\n            u = utxt.get()\n            angle = atxt.get()\n            h = htxt.get()\n            \n            # Strips data for further use\n            angle=float(angle.rstrip(\"\\n\"))\n            h=float(h.rstrip(\"\\n\"))\n            u=float(u.rstrip(\"\\n\"))\n            \n            # Converts from degrees to radians\n            theta = (angle * np.pi) / 180\n            \n            # If statement to determine what value of g should be used\n            if gtxt.get() != \"\":\n                 g=gtxt.get()\n                 g=float(g.rstrip(\"\\n\"))\n            else:\n                g=pre_g\n            \n            # Produces an error if the height is less than 0\n            if h &lt; 0:\n                exit()\n\n            # Resloves forces into horizontal and vertical component\n            costheta = math.cos(theta)\n            sintheta = math.sin(theta)\n\n            ux = u * costheta\n            uy = u * sintheta\n            \n            # Calculates the range and time of flight of the projectile\n            R = (u**2 / g) * (sintheta*costheta+costheta*math.sqrt(sintheta**2 + ((2 * g * h) / (u**2))))\n            tflight = R / (u * costheta)\n\n            # Creates the figure\n            fig, ax = plt.subplots()\n\n            # Creates an empty arrary for the x and y coordinates of the trajectory\n            x = []\n            y = []\n\n            # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n            for i in np.arange(0, tflight, 0.01):\n                t = i\n                x.append(ux * t)\n                T = t * t\n                y.append(h + (uy * t) - (0.5 * g * T))            \n\n            # Apogee calculation\n            apy = (0 - (uy*uy)) / (2 * g * -1) + h\n            tflight0 = 2 * uy / g\n            apx = (ux * tflight0) / 2\n            \n            # Generates the calculated values text\n            # Time of flight phrase\n            tflightph = \"T=\" + str(round(tflight, 2)) + \" s\"\n            label3 = CTkLabel(master=frame2, text=tflightph)\n            label3.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label3.place(x=80, y=40)\n                \n            # Range phrase\n            travel = \"R=\" + str(round(R, 2)) + \" m\"    \n            label4 = CTkLabel(master=frame2, text=travel)\n            label4.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label4.place(x=80, y=80)\n\n            # Distance travelled calculation\n            lim1 = np.tan(theta)\n            lim2 = np.tan(theta) - (g * R) / (u**2) * (1 + np.tan(theta)**2)\n            sc = u**2 / (g * (1 + np.tan(theta)**2))\n            lim1_calc = 0.5 * np.log(abs(np.sqrt(1 + lim1**2) + lim1)) + 0.5 * lim1 * np.sqrt(1 + lim1**2)\n            lim2_calc = 0.5 * np.log(abs(np.sqrt(1 + lim2**2) + lim2)) + 0.5 * lim2 * np.sqrt(1 + lim2**2)\n\n            s = sc * (lim1_calc - lim2_calc)\n\n            # Distance travelled phrase\n            dis = \"s=\" + str(round(s, 2)) + \" m\"    \n            label4 = CTkLabel(master=frame2, text=dis)\n            label4.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label4.place(x=80, y=120)\n            \n            # Calculates maximum theta\n            u2 = u * u\n            tgh = 2 * g * h\n            tghu2 = (tgh) / (u2)\n            arc = (1 / (math.sqrt(2 + tghu2)))\n            \n            thetamax = np.arcsin(arc)\n            \n            max_ux = u * math.cos(thetamax)\n            max_uy = u * math.sin(thetamax)\n            \n            # Creates an empty array for the x and y coordinates of the trajectory\n            max_x = []\n            max_y = []\n\n            # Calculates the range and time of flight of the projectile\n            max_R = (u**2 / g) * math.sqrt(1 + (2 * g * h/ u**2))\n            max_tflight = max_R / max_ux\n\n            # Plots the maximum range projectile\n            for max_i in np.arange(0, max_tflight, 0.01):\n                max_t = max_i\n                max_x.append(max_ux * max_t)\n                max_T = max_t * max_t\n                max_y.append(h + (max_uy * max_t) - (0.5 * g * max_T))\n                \n            # Apogee calculation\n            max_apy = (0 - (max_uy*max_uy)) / (2 * g * -1) + h\n\n            # Compares the y values of the two apogees\n            def compapy(apy, max_apy):\n                if apy &gt; max_apy:\n                    return apy\n                else:\n                    return max_apy\n            y_graph = compapy(apy, max_apy) * 1.1 \n            \n            # Generates the calculated values text\n            # Time of flight phrase\n            tflightph = \"Tₘₐₓ=\" + str(round(max_tflight, 2)) + \" s\"\n            label5 = CTkLabel(master=frame2, text=tflightph)\n            label5.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label5.place(x=80, y=60)\n                \n            # Range phrase\n            travel = \"Rₘₐₓ= \" + str(round(max_R, 2)) + \" m\"    \n            label6 = CTkLabel(master=frame2, text=travel)\n            label6.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label6.place(x=80, y=100)\n\n            # Max distance travelled calculation\n            maxlim1 = np.tan(thetamax)\n            maxlim2 = np.tan(thetamax) - (g * max_R) / (u**2) * (1 + np.tan(thetamax)**2)\n            maxsc = u**2 / (g * (1 + np.tan(thetamax)**2))\n            maxlim1_calc = 0.5 * np.log(abs(np.sqrt(1 + maxlim1**2) + maxlim1)) + 0.5 * maxlim1 * np.sqrt(1 + maxlim1**2)\n            maxlim2_calc = 0.5 * np.log(abs(np.sqrt(1 + maxlim2**2) + maxlim2)) + 0.5 * maxlim2 * np.sqrt(1 + maxlim2**2)\n\n            maxs = maxsc * (maxlim1_calc - maxlim2_calc)\n\n            # Max distance travelled phrase\n            maxdis = \"sₘₐₓ=\" + str(round(maxs, 2)) + \" m\"    \n            label4 = CTkLabel(master=frame2, text=maxdis)\n            label4.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label4.place(x=80, y=140)\n\n            #Time of flight calculation\n            max_tflighta = 2 * max_uy / g\n            max_apx = (max_ux * max_tflighta) / 2\n\n            # Sets parameters of the plot\n            ax.set_xlabel(\"Displacement in x / m\")\n            ax.set_ylabel(\"Displacement in y / m\")\n            ax.set_ylim(0, y_graph)\n            ax.set_xlim(0, max_R)\n            \n            # Creates figure\n            fig1, = ax.plot(x, y, color=\"blue\", label=\"Custom Projectile\")\n            # Plots graphs and apogees\n            ax.plot(max_x, max_y, color=\"orange\", label=\"Maximum Range Projectile\")\n            ax.scatter(apx, apy, color=\"blue\")\n            ax.scatter(max_apx, max_apy, color=\"orange\")\n            ax.grid()\n            \n            ax.legend(loc=\"upper right\")\n            \n            # Creates a canvas in the app for the plot to appear\n            canvas = FigureCanvasTkAgg(fig,master=frame3)\n            canvas.get_tk_widget().place(relx=0.012, rely=0.013, height=700, width=1000)\n            canvas.draw()\n            \n            # Creates a save button for png image\n            img_btn = CTkButton(master=frame4, text=\"SAVE AS PNG\", command=image_handler, width=100, height=30)\n            img_btn.pack(anchor=\"n\")\n            img_btn.place(relx=0.23, rely=0.3)\n\n        label10 = CTkLabel(master=app, text=\"Challenge 6: Adding Distance Travelled to the Projectile Model\", font=(\"Helvetica\", 40))\n        label10.pack(anchor=\"s\", expand=True, padx=10)\n        label10.place(relx=0.14, rely=0.02)\n\n        # Creates the label for the parameters frame\n        label1 = CTkLabel(master=frame1, text=\"Enter Parameters Below:\")\n        label1.pack(anchor=\"s\", expand=True, pady=10, padx=30)\n        label1.place(relx=0.22, rely=0.05)\n\n        # Creates the label for the calculated valeues frame\n        label2 = CTkLabel(master=frame2, text=\"Calculated Values:\")\n        label2.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n        label2.place(relx=0.3, rely=0.05)\n\n        # Creates input text fields for the parameters\n        # Initial velocity field\n        utxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Initial velocity in ms⁻¹\")\n        utxt.place(relx=0.5, rely=0.15, anchor=\"n\")\n\n        # Angle field\n        atxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Angle in °\")\n        atxt.place(relx=0.5, rely=0.25, anchor=\"n\")\n\n        # Initial height field\n        htxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Height in m\")\n        htxt.place(relx=0.5, rely=0.35, anchor=\"n\")\n\n        # Creates a submission button\n        btn = CTkButton(master=frame1, text=\"Submit\", command=click_handler, width=100, height=30)\n        btn.pack(anchor=\"n\")\n        btn.place(relx=0.3, rely=0.75)\n\n        # Creates a label for values of g\n        label3 = CTkLabel(master=frame1, text=\"Set a prefab or custom value for g:\")\n        label3.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n        label3.place(relx=0.11, rely=0.45)\n\n        # Creates input text field for a custom value of g\n        gtxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Custom value for g\")\n        gtxt.place(relx=0.5, rely=0.65, anchor=\"n\")\n\n        # Array of popular objects to obtain a prefab value for g\n        objects = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\", \"Sun\", \"Moon\"]\n        # Creates a combobox to select a prefab value for g\n        combo = CTkComboBox(master=frame1, width=200, height=20, values=objects, command=g_picker, state=\"readonly\")\n        combo.place(relx=0.5, rely=0.55, anchor=\"n\")\n        combo.set(\"Use a prefab value for g\")\n\n    elif challenge == \"Challenge 7\":\n        frame3 = CTkFrame(master=app, border_width=2, height=725, width=1250)\n        frame3.pack(anchor=\"n\", expand=True, padx=20)\n        frame3.place(x = 25, rely=0.08)\n        \n        # Defines parameters of frame4\n        frame4 = CTkFrame(master=app, border_width=2, height=250, width=175)\n        frame4.pack(anchor=\"n\", expand=True, padx=20)\n        frame4.place(relx=0.875, rely=0.08)\n   \n        # Creates a reset button\n        def delete7():\n            frame3.destroy()\n            frame4.destroy()\n            label10.destroy()\n\n            # Background image            \n            image_path = os.path.join(os.path.dirname(__file__), 'bg.png')\n            bg = CTkImage(light_image = Image.open(image_path), size=(1500,825))\n            global image_label \n            image_label = CTkLabel(master=app, image = bg, text='')\n            image_label.place(x=0, y=0)\n            \n            # Array of challenges to select\n            challenges = [\"Challenge 1 & 2\", \"Challenge 3\", \"Challenge 4\", \"Challenge 5\",\"Challenge 6\", \"Challenge 7\", \"Challenge 8\", \"Challenge 9\"]\n            # Creates a combobox to select a prefab value for g\n            global chal_combo\n            chal_combo = CTkComboBox(master=app, width=300, height=50, values=challenges, command=chal_picker, state=\"readonly\")\n            chal_combo.place(x=65, y=400)\n\n        # Function to plot r\n        def rplot(a):\n            # Paramaters\n            u = 10\n            g = 10\n\n            arad = (a * np.pi) / 180\n\n            # Sin and cos of the angle\n            sintheta = np.sin(arad)\n\n            # Creates array of r and t valuse\n            range = []\n\n            # Appends array with inital conditions\n            range.append(0)\n\n            # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n            for i in np.arange(0, 2.6, 0.01):\n                t = i\n                r = np.sqrt(u**2 * t**2 - g * t**3 * u * sintheta + 0.25 * g**2 * t**4)\n                range.append(r)\n                \n            return range\n\n        # Function to plot t\n        def tplot():\n\n            # Creates array for time valuse\n            time = []\n\n            # Appends array with inital condition\n            time.append(0)\n\n            # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n            for i in np.arange(0, 2.6, 0.01):\n                t = i\n                time.append(t)\n                \n            return time\n\n        # Passes parameters of angles \n        r1 = rplot(30)\n        r2 = rplot(45)\n        r3 = rplot(60)\n        r4 = rplot(70.5)\n        r5 = rplot(78)\n        r6 = rplot(85)\n\n        t = tplot()\n\n        # Function to find the t coordinate of the minima\n        def mint(a):\n            u = 10\n            g = 10\n            a = a * (np.pi/180)\n\n            t = ((3 * u) / (2 * g)) * (np.sin(a) + np.sqrt(np.sin(a)**2 - (8/9)))\n\n            return t\n\n        # Calls function and passses angle parameters\n        mint1 = mint(78)\n        mint2 = mint(85)\n\n        # Function to find the r coordinate of the minima\n        def minr(a, t):\n            u = 10\n            g = 10\n            a = a * (np.pi/180)\n\n            r = np.sqrt(u**2 * t**2 - g * t**3 * u * np.sin(a) + 0.25 * g**2 * t**4)\n\n            return r\n        \n        # Calls function and passes angle and t paramaters \n        minr1 = minr(78, mint1)\n        minr2 = minr(85, mint2)\n\n        # Function to find the t coordinate of the maxima \n        def maxt(a):\n            u = 10\n            g = 10\n            a = a * (np.pi/180)\n\n            t = ((3 * u) / (2 * g)) * (np.sin(a) - np.sqrt(np.sin(a)**2 - (8/9)))\n\n            return t\n\n        # Calls function and passes angle parameters\n        maxt1 = maxt(78)\n        maxt2 = maxt(85)\n\n        # Function to find the r coordinate of the maxima\n        def maxr(a, t):\n            u = 10\n            g = 10\n            a = a * (np.pi/180)\n\n            r = np.sqrt(u**2 * t**2 - g * t**3 * u * np.sin(a) + 0.25 * g**2 * t**4)\n\n            return r\n\n        # Calls the function and passes t coordinates and angles\n        maxr1 = maxr(78, maxt1)\n        maxr2 = maxr(85, maxt2)\n\n        # Finds t and r coordinate of the point of inflection\n        def stat():\n            u = 10\n            g = 10\n\n            t = (u / g) * np.sqrt(2)\n\n            return t \n        \n        stat1 = stat()\n\n        def star(a, t):\n            u = 10\n            g = 10\n            a = a * (np.pi / 180)\n\n            r = np.sqrt(u**2 * t**2 - g * t**3 * u * np.sin(a) + 0.25 * g**2 * t**4)\n\n            return r    \n        \n        star1 = star(70.5, stat1) \n\n        fig1, ax = plt.subplots()\n\n        # Sets the parameters of the plot\n        ax.set_xlabel(\"Time, t / s\")\n        ax.set_ylabel(\"Range, r / m\")\n        ax.set_ylim(0, 30)\n        ax.set_xlim(0, 2.5)\n        ax.set_title(\"Range, r against time, t\")\n\n        # Components to be plotted\n        ax.plot(t, r1, label=\"θ = 30°\")\n        ax.plot(t, r2, label=\"θ = 45°\")\n        ax.plot(t, r3, label=\"θ = 60°\")\n        ax.plot(t, r4, label=\"θ = 70.5°\")\n        ax.plot(t, r5, label=\"θ = 78°\")\n        ax.plot(t, r6, label=\"θ = 85°\")\n        \n        # Plots minima\n        ax.scatter(mint1, minr1, color=\"black\", marker=\"x\")\n        ax.scatter(mint2, minr2, color=\"black\", marker=\"x\")\n\n        # Plots maxima\n        ax.scatter(maxt1, maxr1, color=\"red\", marker=\"x\")\n        ax.scatter(maxt2, maxr2, color=\"red\", marker=\"x\")\n\n        # Plots point of inflection\n        ax.scatter(stat1, star1, color=\"blue\", marker=\"x\")\n\n        ax.grid()\n\n        ax.legend()\n            \n        def xplot(a):\n            u = 10\n            g = 10\n\n            arad = (a * np.pi) / 180\n\n            ux = u * np.cos(arad)\n\n            # Creates an empty arrary for the x and y coordinates of the trajectory\n            x = []\n\n            # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n            for i in np.arange(0, 3, 0.01):\n                t = i\n                x.append(ux * t)\n\n            return x\n\n        def yplot(a):\n            u = 10\n            g = 10\n            h = 0\n\n            arad = (a * np.pi) / 180\n\n            uy = u * np.sin(arad)\n\n            # Creates an empty arrary for the x and y coordinates of the trajectory\n            y = []\n\n            # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n            for i in np.arange(0, 3, 0.01):\n                t = i\n                T = t * t\n                y.append(h + (uy * t) - (0.5 * g * T))   \n\n            return y    \n\n        # Plots maxima, minima and inflection points on y against x graph\n        \n        # Function to find x coordinate of each stationary point\n        def stax(a, t):\n            u = 10\n            g = 10\n            a = a * (np.pi / 180)\n\n            ux = u * np.cos(a)\n\n            x = ux * t\n\n            return x\n\n        # Calls function and passes paramters angle and t\n        stax1 = stax(78, mint1)\n        stax2 = stax(85, mint2)\n        stax3 = stax(78, maxt1)\n        stax4 = stax(85, maxt2)\n        stax5 = stax(70.5, stat1)\n\n        # Function to find the y coordinate of each stationary point\n        def stay(a, t):\n            u = 10\n            g = 10\n            a = a * (np.pi / 180)\n\n            uy = u * np.sin(a)\n\n            y = uy * t - 0.5 * g * t**2\n\n            return y\n\n        # Calls function and passes paramaters angle and t\n        stay1 = stay(78, mint1)\n        stay2 = stay(85, mint2)\n        stay3 = stay(78, maxt1)\n        stay4 = stay(85, maxt2)\n        stay5 = stay(70.5, stat1)\n\n        fig2, ax = plt.subplots()\n\n        # Passes parameters of angles \n        x1 = xplot(30)\n        x2 = xplot(45)\n        x3 = xplot(60)\n        x4 = xplot(70.5)\n        x5 = xplot(78)\n        x6 = xplot(85)\n\n        # Passes parameters of angles \n        y1 = yplot(30)\n        y2 = yplot(45)\n        y3 = yplot(60)\n        y4 = yplot(70.5)\n        y5 = yplot(78)\n        y6 = yplot(85)\n\n        # Components to be plotted\n        ax.plot(x1, y1, label=\"θ = 30°\")\n        ax.plot(x2, y2, label=\"θ = 45°\")\n        ax.plot(x3, y3, label=\"θ = 60°\")\n        ax.plot(x4, y4, label=\"θ = 70.5°\")\n        ax.plot(x5, y5, label=\"θ = 78°\")\n        ax.plot(x6, y6, label=\"θ = 85°\")\n        ax.grid()\n\n        # Plots stationary points\n        ax.scatter(stax1, stay1, color=\"black\", marker=\"x\")\n        ax.scatter(stax2, stay2, color=\"black\", marker=\"x\")\n        ax.scatter(stax3, stay3, color=\"red\", marker=\"x\")\n        ax.scatter(stax4, stay4, color=\"red\", marker=\"x\")\n        ax.scatter(stax5, stay5, color=\"blue\", marker=\"x\")\n\n        # Sets the parameters of the plot\n        ax.set_xlabel(\"Displacement in x / m\")\n        ax.set_ylabel(\"Displacement in y / m\")\n        ax.set_ylim(-5, 5)\n        ax.set_xlim(0, 15)\n        ax.set_title(\"Trajectories\")\n\n        ax.legend()\n            \n        # Creates a canvas in the app for the plot to appear\n        canvas = FigureCanvasTkAgg(fig1,master=frame3)\n        canvas.get_tk_widget().place(x=15, rely=0.013, height=700, width=600)\n        canvas.draw()\n\n        # Creates a canvas in the app for the plot to appear\n        canvas = FigureCanvasTkAgg(fig2,master=frame3)\n        canvas.get_tk_widget().place(x=635, rely=0.013, height=700, width=600)\n        canvas.draw()\n\n        del_btn = CTkButton(master=frame4, text=\"RETURN TO HOME\", command=delete7, width=100, height=30)\n        del_btn.pack(anchor=\"n\")\n        del_btn.place(relx=0.175, rely=0.075)\n\n        label10 = CTkLabel(master=app, text=\"Challenge 7: Minima and Maxima\", font=(\"Helvetica\", 40))\n        label10.pack(anchor=\"s\", expand=True, padx=10)\n        label10.place(relx=0.3, rely=0.02)\n\n    elif challenge == \"Challenge 8\":\n        # Defines parameters of frame1\n        frame1 = CTkFrame(master=app, border_width=2, width=250, height=450)\n        frame1.pack(anchor=\"nw\", expand=True, padx=20, pady=67)\n\n        # Defines parameters of frame2\n        frame2 = CTkFrame(master=app, border_width=2, width=250, height=250)\n        frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n        frame2.place(relx=0.014, rely=0.655)\n        \n        # Defines parameters of frame3\n        frame3 = CTkFrame(master=app, border_width=2, height=725, width=1025)\n        frame3.pack(anchor=\"n\", expand=True, padx=20)\n        frame3.place(relx=0.1875, rely=0.08)\n        \n        # Defines parameters of frame4\n        frame4 = CTkFrame(master=app, border_width=2, height=250, width=175)\n        frame4.pack(anchor=\"n\", expand=True, padx=20)\n        frame4.place(relx=0.875, rely=0.08)\n        \n        # Creates a reset button\n        del_btn = CTkButton(master=frame4, text=\"RETURN TO HOME\", command=delete, width=100, height=30)\n        del_btn.pack(anchor=\"n\")\n        del_btn.place(relx=0.175, rely=0.075)  \n\n        def click_handler():\n            # Defines parameters of frame2\n            frame2 = CTkFrame(master=app, border_width=2, width=250, height=250)\n            frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n            frame2.place(relx=0.014, rely=0.655)\n\n            # Creates the label for the calculated valeues frame\n            label2 = CTkLabel(master=frame2, text=\"Calculated Values:\")\n            label2.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n            label2.place(relx=0.3, rely=0.05)\n\n            # Verlet procedure\n            def verlet(N, C, g, dt, h, a, u):\n                # Initial conditions\n                a = a * (np.pi/180)\n                nbounce = 0\n                t = 0\n                x = 0\n                y = h\n                ux = u * np.cos(a)\n                uy = u * np.sin(a)\n\n                # Defines global arrays plotx and ploty\n                plotx = []\n                ploty = []\n\n                while nbounce &lt;= N:\n                    # Acceleration\n                    ax = 0\n                    ay = -g\n\n                    # Updating position\n                    x = x + ux * dt + 0.5 * ax * dt**2\n                    y = y + uy * dt + 0.5 * ay * dt**2\n                        \n                    # Appends x and y arrays\n                    plotx.append(x)\n                    ploty.append(y)\n\n                    # Update acceleration (Stays the same)\n                    aax = 0\n                    aay = -g\n\n                    # Update velocity\n                    ux = ux + 0.5 * (ax + aax) * dt\n                    uy = uy + 0.5 * (ay + aay) * dt\n\n                    # Checks if the height of the ball is greater than 0\n                    if y &lt; 0:\n                        y = 0\n                        uy = -C * uy\n                        nbounce = nbounce + 1\n\n                    t = t + dt\n\n                # Time of flight of the ball\n                tflight = t\n\n                return tflight, plotx, ploty\n\n            # Retrieves selected parameters\n\n            N = Ntxt.get()\n            N = float(N.rstrip(\"\\n\"))\n\n            C = Ctxt.get()\n            C = float(C.rstrip(\"\\n\"))\n\n            # If statement to determine what value of g should be used\n            if gtxt.get() != \"\":\n                 g=gtxt.get()\n                 g=float(g.rstrip(\"\\n\"))\n            else:\n                g=pre_g\n\n            dt = dttxt.get()\n            dt = float(dt.rstrip(\"\\n\"))\n\n            h = htxt.get()\n            h = float(h.rstrip(\"\\n\"))\n\n            a = atxt.get()\n            a = float(a.rstrip(\"\\n\"))\n\n            u = utxt.get()\n            u = float(u.rstrip(\"\\n\"))\n\n            tflight, plotx, ploty = verlet(N, C, g, dt, h, a, u)\n\n            # Generates the calculated values text\n            # Time of flight phrase\n            tflightph = \"Time of flight: \" + str(round(tflight, 2)) + \" s\"\n            label5 = CTkLabel(master=frame2, text=tflightph)\n            label5.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n            label5.place(relx=0.27, rely=0.2)\n\n            # Result of the UI switcher\n            animcheck = switcher()\n\n            # If the slider of the switcher is off, a normal graph is plotted\n            if animcheck == 0:\n                # Resets frame\n                # Defines parameters of frame4\n                frame4 = CTkFrame(master=app, border_width=2, height=250, width=175)\n                frame4.pack(anchor=\"n\", expand=True, padx=20)\n                frame4.place(relx=0.875, rely=0.08)\n                \n                # Creates a reset button\n                del_btn = CTkButton(master=frame4, text=\"RETURN TO HOME\", command=delete, width=100, height=30)\n                del_btn.pack(anchor=\"n\")\n                del_btn.place(relx=0.175, rely=0.075)\n\n                # Plotting and grid\n                fig, ax = plt.subplots()\n                ax.plot(plotx, ploty)\n                ax.grid()\n\n                # Axes limits\n                ax.set_xlim(0)\n                ax.set_ylim(0)\n\n                # Saves an image png of the figure when a button is pressed\n                def image_handler():\n                    path=\"/Users/Mark Watson/Desktop/Python Projects/BPHO/Projectiles\"\n                    os.chdir(path)\n                    fig.savefig(fname='Challenge8.png',dpi='figure', format='png')\n                \n                # Creates a save button for png image\n                img_btn = CTkButton(master=frame4, text=\"SAVE AS PNG\", command=image_handler, width=100, height=30)\n                img_btn.pack(anchor=\"n\")\n                img_btn.place(relx=0.23, rely=0.3)\n\n            # Otherwise, an animation is plotted\n            elif animcheck == 1:\n                # Resets frame\n                # Defines parameters of frame4\n                frame4 = CTkFrame(master=app, border_width=2, height=250, width=175)\n                frame4.pack(anchor=\"n\", expand=True, padx=20)\n                frame4.place(relx=0.875, rely=0.08)\n                \n                # Creates a reset button\n                del_btn = CTkButton(master=frame4, text=\"RETURN TO HOME\", command=delete, width=100, height=30)\n                del_btn.pack(anchor=\"n\")\n                del_btn.place(relx=0.175, rely=0.075)\n\n                fig, ax = plt.subplots()\n                ax.grid()\n\n                # Creates markers for the ball and trajectory\n                line, = ax.plot([], [], 'r-')\n                ball, = ax.plot([], [], 'ro', markersize=10)\n\n                # Initialises parameters for the animation\n                def init():\n                    # Axes limits\n                    ax.set_xlim(0, max(plotx))\n                    ax.set_ylim(0, (max(ploty) + 0.1 * max(ploty)))\n                    \n                    # Initialises ball and line\n                    line.set_data([], [])\n                    ball.set_data([], [])\n\n                    return line, ball\n\n                # Updates the position of the line and ball for every frame of the animation\n                def update(frame):\n                    line.set_data(plotx[:frame], ploty[:frame])\n                    ball.set_data(plotx[frame], ploty[frame])\n\n                    return line, ball\n\n                # Create an animation with FuncAnimation\n                ani = animation.FuncAnimation(fig, update, frames=range(len(plotx)), init_func=init, interval=10, blit=True)\n\n                def anim_handler():\n                    path=\"/Users/Mark Watson/Desktop/Python Projects/BPHO/Projectiles\"\n                    os.chdir(path)\n\n                    writer = animation.PillowWriter(fps=15, metadata=dict(artist='Me'), bitrate=1800)\n                    ani.save('Challenge8.gif', writer=writer)\n\n                # Creates a save button for png image\n                anim_btn = CTkButton(master=frame4, text=\"SAVE ANIMATION\", command=anim_handler, width=100, height=30)\n                anim_btn.pack(anchor=\"n\")\n                anim_btn.place(relx=0.19, rely=0.3)\n            \n            # Creates a canvas in the app for the plot to appear\n            canvas = FigureCanvasTkAgg(fig,master=frame3)\n            canvas.get_tk_widget().place(relx=0.012, rely=0.013, height=700, width=1000)\n            canvas.draw()\n\n        label10 = CTkLabel(master=app, text=\"Challenge 8: The Bouncing Ball\", font=(\"Helvetica\", 40))\n        label10.pack(anchor=\"s\", expand=True, padx=10)\n        label10.place(relx=0.35, rely=0.02)\n\n        # Creates the label for the parameters frame\n        label1 = CTkLabel(master=frame1, text=\"Enter Parameters Below:\")\n        label1.pack(anchor=\"s\", expand=True, pady=10, padx=30)\n        label1.place(relx=0.22, rely=0.05)\n\n        # Creates the label for the calculated valeues frame\n        label2 = CTkLabel(master=frame2, text=\"Calculated Values:\")\n        label2.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n        label2.place(relx=0.3, rely=0.05)\n\n        # Creates input text fields for the parameters\n        # Initial velocity field\n        utxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Initial velocity in ms⁻¹\")\n        utxt.place(relx=0.5, rely=0.125, anchor=\"n\")\n\n        # Angle field\n        atxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Angle in °\")\n        atxt.place(relx=0.5, rely=0.2, anchor=\"n\")\n\n        # Initial height field\n        htxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Height in m\")\n        htxt.place(relx=0.5, rely=0.275, anchor=\"n\")\n\n        # Coefficient of restitution field\n        Ctxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Coefficient of restitution\")\n        Ctxt.place(relx=0.5, rely=0.35, anchor=\"n\")\n\n        # Number of bounces field\n        Ntxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Maximum number of bounces\")\n        Ntxt.place(relx=0.5, rely=0.425, anchor=\"n\")\n\n        # Timestep field\n        dttxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Timestep in s\")\n        dttxt.place(relx=0.5, rely=0.5, anchor=\"n\")\n\n        # Switch and function to enable animation\n        def switcher():\n            animcheck = switch_var.get()\n            \n            return animcheck\n\n        switch_var = customtkinter.IntVar(value=0)\n        switch = CTkSwitch(master=frame1, text=\"Enable Animation\", variable=switch_var, onvalue=1, offvalue=0)    \n        switch.place(x=47.5, rely=0.81)\n\n        # Creates a submission button\n        btn = CTkButton(master=frame1, text=\"Submit\", command=click_handler, width=100, height=30)\n        btn.pack(anchor=\"n\")\n        btn.place(relx=0.3, rely=0.9)\n\n        # Creates a label for values of g\n        label3 = CTkLabel(master=frame1, text=\"Set a prefab or custom value for g:\")\n        label3.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n        label3.place(relx=0.11, rely=0.575)\n\n        # Creates input text field for a custom value of g\n        gtxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Enter a custom value for g\")\n        gtxt.place(relx=0.5, rely=0.725, anchor=\"n\")\n\n        # Array of popular objects to obtain a prefab value for g\n        objects = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\", \"Sun\", \"Moon\"]\n        # Creates a combobox to select a prefab value for g\n        combo = CTkComboBox(master=frame1, width=200, height=20, values=objects, command=g_picker, state=\"readonly\")\n        combo.place(relx=0.5, rely=0.65, anchor=\"n\")\n        combo.set(\"Use a prefab value for g\") \n\n    elif challenge == \"Challenge 9\":\n        def display():\n            # Deletes challenge and returns to main menu\n            def delete9a():\n                frame1.destroy()\n                frame2.destroy()\n                frame3.destroy()\n                frame4.destroy()\n                label10.destroy()\n\n                main_menu()\n\n            # Deletes challenge 9 but does not open main menu\n            def delete9b():\n                frame1.destroy()\n                frame2.destroy()\n                frame3.destroy()\n                frame4.destroy()\n                label10.destroy()\n\n            def c_drag_picker():\n                # Reset\n                delete9b()\n                menu_delete()\n                \n                # Creates background for menu to select projectile\n                image_path = os.path.join(os.path.dirname(__file__), 'projectile_picker.png')\n\n                projectile_picker = CTkImage(light_image = Image.open(image_path), size=(1500,825)) \n                image_label2 = CTkLabel(master=app, image = projectile_picker, text='')\n                image_label2.place(x=0, y=0)\n\n                # Creates 10 radio button options for the user to select a desireable drag coefficient\n                # Creates the radio_var variable to store the result of the radio button\n                global radio_var            \n                radio_var = StringVar(value = \"other\")\n\n                rad1 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 1\", variable=radio_var, bg_color=\"#eeeeee\")\n                rad1.place(x=500, y=200)\n\n                rad2 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 2\", variable=radio_var, bg_color=\"#eeeeee\")\n                rad2.place(x=500, y=337.5)\n\n                rad3 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 3\", variable=radio_var, bg_color=\"#eeeeee\")\n                rad3.place(x=500, y=475)\n\n                rad4 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 4\", variable=radio_var, bg_color=\"#eeeeee\")\n                rad4.place(x=500, y=612.5)\n\n                rad5 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 5\", variable=radio_var, bg_color=\"#eeeeee\")\n                rad5.place(x=500, y=750)\n\n                rad6 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 6\", variable=radio_var, bg_color=\"white\")\n                rad6.place(x=1250, y=200)\n\n                rad7 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 7\", variable=radio_var, bg_color=\"white\")\n                rad7.place(x=1250, y=337.5)\n\n                rad8 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 8\", variable=radio_var, bg_color=\"white\")\n                rad8.place(x=1250, y=475)\n\n                rad9 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 9\", variable=radio_var, bg_color=\"white\")\n                rad9.place(x=1250, y=612.5)\n\n                rad10 = CTkRadioButton(master=app, text=\" \", value=\"Custom\", variable=radio_var, bg_color=\"white\")\n                rad10.place(x=1325, y=715)\n\n                # Creates a procedure to return to the main menu\n                def delete_picker1a():\n                    image_label2.destroy()\n                    rad1.destroy()\n                    rad2.destroy()\n                    rad3.destroy()\n                    rad4.destroy()\n                    rad5.destroy()\n                    rad6.destroy()\n                    rad7.destroy()\n                    rad8.destroy()\n                    rad9.destroy()\n                    rad10.destroy()\n                    del_btn.destroy()\n                    btn.destroy()\n                    c_dragtxt.destroy()\n\n                    delete9a()\n\n                # Procedure to select a drag coefficient            \n                def delete_picker2a():\n                    image_label2.destroy()\n                    rad1.destroy()\n                    rad2.destroy()\n                    rad3.destroy()\n                    rad4.destroy()\n                    rad5.destroy()\n                    rad6.destroy()\n                    rad7.destroy()\n                    rad8.destroy()\n                    rad9.destroy()\n                    rad10.destroy()\n                    del_btn.destroy()\n                    btn.destroy()\n\n                    # Obtains value for drag coefficient entered into the text field\n                    if radio_var.get() == \"Custom\":\n                        global customc_drag\n                        customc_drag = c_dragtxt.get()                    \n                        customc_drag=float(customc_drag.rstrip(\"\\n\"))\n\n                    c_dragtxt.destroy()\n                        \n                    display()\n                    \n                c_dragtxt = CTkEntry(master=app, width=200, height=50, placeholder_text=\"Enter a custom drag coefficient\")\n                c_dragtxt.place(x=1075, y=700)\n\n                # Creates a reset button\n                del_btn = CTkButton(master=app, text=\"RETURN TO HOME\", command=delete_picker1a, width=100, height=50)\n                del_btn.pack(anchor=\"n\")\n                del_btn.place(x=1250, y=50)\n\n                # Creates a submission button\n                btn = CTkButton(master=app, text=\"SUBMIT\", command=delete_picker2a, width=100, height=50)\n                btn.pack(anchor=\"n\")\n                btn.place(x=1050, y=50)\n\n            # Defines parameters of frame1\n            frame1 = CTkFrame(master=app, border_width=2, width=250, height=450)\n            frame1.pack(anchor=\"nw\", expand=True, padx=20, pady=67)\n\n            # Defines parameters of frame2\n            frame2 = CTkFrame(master=app, border_width=2, width=250, height=250)\n            frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n            frame2.place(relx=0.014, rely=0.655)\n            \n            # Defines parameters of frame3\n            frame3 = CTkFrame(master=app, border_width=2, height=725, width=1025)\n            frame3.pack(anchor=\"n\", expand=True, padx=20)\n            frame3.place(relx=0.1875, rely=0.08)\n            \n            # Defines parameters of frame4\n            frame4 = CTkFrame(master=app, border_width=2, height=250, width=175)\n            frame4.pack(anchor=\"n\", expand=True, padx=20)\n            frame4.place(relx=0.875, rely=0.08)\n            \n            # Creates a reset button\n            del_btn = CTkButton(master=frame4, text=\"RETURN TO HOME\", command=delete9a, width=100, height=30)\n            del_btn.pack(anchor=\"n\")\n            del_btn.place(relx=0.175, rely=0.075)\n\n            # Function that occurs when the submit button is pressed\n            def click_handler():\n                # Determines a value for the coefficient of drag based on the user's preference\n                if radio_var.get() == \"Projectile 1\":\n                    c_drag = 0.47\n                elif radio_var.get() == \"Projectile 2\":\n                    c_drag = 0.42\n                elif radio_var.get() == \"Projectile 3\":\n                    c_drag = 0.5\n                elif radio_var.get() == \"Projectile 4\":                \n                    c_drag = 1.0\n                elif radio_var.get() == \"Projectile 5\":\n                    c_drag = 0.8\n                elif radio_var.get() == \"Projectile 6\":\n                    c_drag = 0.82\n                elif radio_var.get() == \"Projectile 7\":\n                    c_drag = 1.15\n                elif radio_var.get() == \"Projectile 8\":\n                    c_drag = 0.04\n                elif radio_var.get() == \"Projectile 9\":\n                    c_drag = 0.09\n                elif radio_var.get() == \"Custom\":\n                    c_drag = customc_drag\n                else:\n                    c_drag = 1\n            \n                # Defines parameters of frame2\n                frame2 = CTkFrame(master=app, border_width=2, width=250, height=250)\n                frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n                frame2.place(relx=0.014, rely=0.655)\n\n                # Creates the label for the calculated valeues frame\n                label2 = CTkLabel(master=frame2, text=\"Calculated Values:\")\n                label2.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n                label2.place(relx=0.3, rely=0.05)\n                \n                # Takes parameters u, angle and h from input text fields\n                u = utxt.get()\n                angle = atxt.get()\n                h = htxt.get()\n                \n                # If statement to determine what value of g should be used\n                if gtxt.get() != \"\":\n                    g=gtxt.get()\n                    g=float(g.rstrip(\"\\n\"))\n                else:\n                    g=pre_g\n                \n                # Strips the text to remove blank spaces\n                angle=float(angle.rstrip(\"\\n\"))\n                h=float(h.rstrip(\"\\n\"))\n                u=float(u.rstrip(\"\\n\"))\n                \n                # Converts the angle to radians\n                theta = (angle * np.pi) / 180\n                \n                # Produces an error if the height is less than 0\n                if h &lt; 0:\n                    exit()\n\n                # Resloves forces into horizontal and vertical component\n                costheta = math.cos(theta)\n                sintheta = math.sin(theta)\n\n                ux = u * costheta\n                uy = u * sintheta\n                \n                # Calculates the range and time of flight of the projectile\n                R = (u**2 / g) * (sintheta*costheta+costheta*math.sqrt(sintheta**2 + ((2 * g * h) / (u**2))))\n                tflight = R / (u * costheta)\n\n                # Creates an empty arrary for the x and y coordinates of the trajectory\n                x = []\n                y = []\n\n                # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n                for i in np.arange(0, tflight, 0.01):\n                    t = i\n                    x.append(ux * t)\n                    T = t * t\n                    y.append(h + (uy * t) - (0.5 * g * T))            \n\n                # Apogee calculation\n                apy = (0 - (uy*uy)) / (2 * g * -1) + h\n                y_graph = apy + 5\n                \n                # Generates the calculated values text\n                # Time of flight phrase\n                tflightph = \"Time of flight: \" + str(round(tflight, 2)) + \" s\"\n                label5 = CTkLabel(master=frame2, text=tflightph)\n                label5.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n                label5.place(relx=0.27, rely=0.2)\n                    \n                # Range phrase\n                travel = \"Range: \" + str(round(R, 2)) + \" m\"    \n                label6 = CTkLabel(master=frame2, text=travel)\n                label6.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n                label6.place(relx=0.31, rely=0.35)\n\n                # Parameters to determine k\n                density = densitytxt.get()\n                m = mtxt.get()\n                A = Atxt.get()\n                dt = 0.01\n\n                density=float(density.rstrip(\"\\n\"))\n                m=float(m.rstrip(\"\\n\"))\n                A=float(A.rstrip(\"\\n\"))\n\n                # Calculation for k\n                k = (0.5 * c_drag * density * A) / m\n\n                # Creates arrays for air resistance x and y values\n                x_plot = []\n                y_plot = []\n\n                # Sets initial x and y values\n                d_x = 0\n                d_y = h\n                \n                # Adds initial x and y values to the arrays\n                x_plot.append(d_x)\n                y_plot.append(d_y)\n\n                # Verlet method to update the acceleration, velocity and position of the projectile after each discrete timestep\n                n = 0\n                t_drag = 0\n                while y_plot[n] &gt;= 0:\n                    t_drag = t_drag + dt\n                    ax = - (ux / u) * k * u**2\n                    ay = - g - (uy / u) * k * u**2\n                    d_x = d_x + ux * dt + 0.5 * ax * dt**2\n                    d_y = d_y + uy * dt + 0.5 * ay * dt**2\n                    x_plot.append(d_x)\n                    y_plot.append(d_y)\n                    ux = ux + ax * dt\n                    uy = uy + ay * dt\n                    u = math.sqrt(ux**2 + uy**2)\n\n                    n = n + 1\n\n                # Generates the calculated values text\n                # Time of flight phrase for drag\n                tflightph = \"Time of flight (drag): \" + str(round(t_drag, 2)) + \" s\"\n                label5 = CTkLabel(master=frame2, text=tflightph)\n                label5.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n                label5.place(relx=0.27, rely=0.5)\n\n                R_drag = x_plot[n]\n                # Range phrase for drag\n                travel = \"Range (drag): \" + str(round(R_drag, 2)) + \" m\"    \n                label6 = CTkLabel(master=frame2, text=travel)\n                label6.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n                label6.place(relx=0.31, rely=0.65)\n\n                # Creates the figure\n                fig, ax = plt.subplots()\n\n                # Sets the parameters of the plot\n                ax.set_xlabel(\"Displacement in x / m\")\n                ax.set_ylabel(\"Displacement in y / m\")\n                ax.set_ylim(0, y_graph)\n                ax.set_xlim(0, R)\n\n                # Components to be plotted\n                ax.plot(x, y, label=\"No Air Resistance\")\n                ax.grid()\n                ax.plot(x_plot, y_plot, label=\"Air Resistance\")\n\n                ax.legend()\n                \n                # Creates a canvas in the app for the plot to appear\n                canvas = FigureCanvasTkAgg(fig,master=frame3)\n                canvas.get_tk_widget().place(relx=0.012, rely=0.013, height=700, width=1000)\n                canvas.draw()\n\n                # Saves an image png of the figure when a button is pressed\n                def image_handler():\n                    path=\"/Users/Mark Watson/Desktop/Python Projects/BPHO/Projectiles\"\n                    os.chdir(path)\n                    fig.savefig(fname='Challenge9.png',dpi='figure', format='png')\n                \n                # Creates a save button for png image\n                img_btn = CTkButton(master=frame4, text=\"SAVE AS PNG\", command=image_handler, width=100, height=30)\n                img_btn.pack(anchor=\"n\")\n                img_btn.place(relx=0.23, rely=0.3)\n\n            label10 = CTkLabel(master=app, text=\"Challenge 9: The effects of Air Resistance\", font=(\"Helvetica\", 40))\n            label10.pack(anchor=\"s\", expand=True, padx=10)\n            label10.place(relx=0.3, rely=0.02)\n\n            # Creates the label for the parameters frame\n            label1 = CTkLabel(master=frame1, text=\"Enter Parameters Below:\")\n            label1.pack(anchor=\"s\", expand=True, pady=10, padx=30)\n            label1.place(relx=0.22, rely=0.05)\n\n            # Creates the label for the calculated valeues frame\n            label2 = CTkLabel(master=frame2, text=\"Calculated Values:\")\n            label2.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n            label2.place(relx=0.3, rely=0.05)\n\n            # Creates input text fields for the parameters\n            # Initial velocity field\n            utxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Initial velocity in ms⁻¹\")\n            utxt.place(relx=0.5, rely=0.125, anchor=\"n\")\n\n            # Angle field\n            atxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Angle in °\")\n            atxt.place(relx=0.5, rely=0.2, anchor=\"n\")\n\n            # Initial height field\n            htxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Height in m\")\n            htxt.place(relx=0.5, rely=0.275, anchor=\"n\")\n\n            # Air density field\n            densitytxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Air density in kgm⁻³\")\n            densitytxt.place(relx=0.5, rely=0.35, anchor=\"n\")\n\n            # Mass field\n            mtxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Mass of the projectile in kg\")\n            mtxt.place(relx=0.5, rely=0.425, anchor=\"n\")\n\n            # Area field\n            Atxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Cross-sectional area in m²\")\n            Atxt.place(relx=0.5, rely=0.5, anchor=\"n\")\n\n            # Allows the user to select a different drag coefficient\n            btn = CTkButton(master=frame1, text=\"Change Drag Coefficient\", command=c_drag_picker, width=100, height=30)\n            btn.place(relx=0.2, rely=0.8)\n\n            # Creates a submission button\n            btn = CTkButton(master=frame1, text=\"Submit\", command=click_handler, width=100, height=30)\n            btn.pack(anchor=\"n\")\n            btn.place(relx=0.3, rely=0.9)\n\n            # Creates a label for values of g\n            label3 = CTkLabel(master=frame1, text=\"Set a prefab or custom value for g:\")\n            label3.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n            label3.place(relx=0.11, rely=0.575)\n\n            # Creates input text field for a custom value of g\n            gtxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Enter a custom value for g\")\n            gtxt.place(relx=0.5, rely=0.725, anchor=\"n\")\n\n            # Array of popular objects to obtain a prefab value for g\n            objects = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\", \"Sun\", \"Moon\"]\n            # Creates a combobox to select a prefab value for g\n            combo = CTkComboBox(master=frame1, width=200, height=20, values=objects, command=g_picker, state=\"readonly\")\n            combo.place(relx=0.5, rely=0.65, anchor=\"n\")\n            combo.set(\"Use a prefab value for g\")\n\n        # Creates background for menu to select projectile\n        image_path = os.path.join(os.path.dirname(__file__), 'projectile_picker.png')\n\n        projectile_picker = CTkImage(light_image = Image.open(image_path), size=(1500,825)) \n        image_label2 = CTkLabel(master=app, image = projectile_picker, text='')\n        image_label2.place(x=0, y=0)\n\n        # Creates 10 radio button options for the user to select a desireable drag coefficient\n        # Creates the radio_var variable to store the result of the radio button\n        global radio_var            \n        radio_var = StringVar(value = \"other\")\n\n        rad1 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 1\", variable=radio_var, bg_color=\"#eeeeee\")\n        rad1.place(x=500, y=200)\n\n        rad2 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 2\", variable=radio_var, bg_color=\"#eeeeee\")\n        rad2.place(x=500, y=337.5)\n\n        rad3 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 3\", variable=radio_var, bg_color=\"#eeeeee\")\n        rad3.place(x=500, y=475)\n\n        rad4 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 4\", variable=radio_var, bg_color=\"#eeeeee\")\n        rad4.place(x=500, y=612.5)\n\n        rad5 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 5\", variable=radio_var, bg_color=\"#eeeeee\")\n        rad5.place(x=500, y=750)\n\n        rad6 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 6\", variable=radio_var, bg_color=\"white\")\n        rad6.place(x=1250, y=200)\n\n        rad7 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 7\", variable=radio_var, bg_color=\"white\")\n        rad7.place(x=1250, y=337.5)\n\n        rad8 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 8\", variable=radio_var, bg_color=\"white\")\n        rad8.place(x=1250, y=475)\n\n        rad9 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 9\", variable=radio_var, bg_color=\"white\")\n        rad9.place(x=1250, y=612.5)\n\n        rad10 = CTkRadioButton(master=app, text=\" \", value=\"Custom\", variable=radio_var, bg_color=\"white\")\n        rad10.place(x=1325, y=715)\n\n        # Creates a procedure to return to the main menu\n        def delete_picker1():\n            image_label2.destroy()\n            rad1.destroy()\n            rad2.destroy()\n            rad3.destroy()\n            rad4.destroy()\n            rad5.destroy()\n            rad6.destroy()\n            rad7.destroy()\n            rad8.destroy()\n            rad9.destroy()\n            rad10.destroy()\n            del_btn.destroy()\n            btn.destroy()\n            c_dragtxt.destroy()\n\n            main_menu()\n\n        # Procedure to select a drag coefficient            \n        def delete_picker2():\n            image_label2.destroy()\n            rad1.destroy()\n            rad2.destroy()\n            rad3.destroy()\n            rad4.destroy()\n            rad5.destroy()\n            rad6.destroy()\n            rad7.destroy()\n            rad8.destroy()\n            rad9.destroy()\n            rad10.destroy()\n            del_btn.destroy()\n            btn.destroy()\n\n            # Obtains value for drag coefficient entered into the text field\n            if radio_var.get() == \"Custom\":\n                global customc_drag\n                customc_drag = c_dragtxt.get()                    \n                customc_drag=float(customc_drag.rstrip(\"\\n\"))\n\n            c_dragtxt.destroy()\n                \n            display()\n            \n        c_dragtxt = CTkEntry(master=app, width=200, height=50, placeholder_text=\"Enter a custom drag coefficient\")\n        c_dragtxt.place(x=1075, y=700)\n\n        # Creates a reset button\n        del_btn = CTkButton(master=app, text=\"RETURN TO HOME\", command=delete_picker1, width=100, height=50)\n        del_btn.pack(anchor=\"n\")\n        del_btn.place(x=1250, y=50)\n\n        # Creates a submission button\n        btn = CTkButton(master=app, text=\"SUBMIT\", command=delete_picker2, width=100, height=50)\n        btn.pack(anchor=\"n\")\n        btn.place(x=1050, y=50)\n    \n    elif challenge == \"Extension\":\n        def display():  \n            # Deletes challenge and returns to main menu\n            def deleteE1a():\n                frame1.destroy()\n                frame2.destroy()\n                frame3.destroy()\n                frame4.destroy()\n                label10.destroy()\n\n                main_menu()\n\n            # Deletes challenge 9 but does not open main menu\n            def deleteE1b():\n                frame1.destroy()\n                frame2.destroy()\n                frame3.destroy()\n                frame4.destroy()\n                label10.destroy()\n\n            def c_drag_picker():\n                # Reset\n                deleteE1b()\n                menu_delete()\n                \n                # Creates background for menu to select projectile\n                image_path = os.path.join(os.path.dirname(__file__), 'projectile_picker.png')\n\n                projectile_picker = CTkImage(light_image = Image.open(image_path), size=(1500,825)) \n                image_label2 = CTkLabel(master=app, image = projectile_picker, text='')\n                image_label2.place(x=0, y=0)\n\n                # Creates 10 radio button options for the user to select a desireable drag coefficient\n                # Creates the radio_var variable to store the result of the radio button\n                global radio_var2            \n                radio_var2 = StringVar(value = \"other\")\n\n                rad1 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 1\", variable=radio_var2, bg_color=\"#eeeeee\")\n                rad1.place(x=500, y=200)\n\n                rad2 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 2\", variable=radio_var2, bg_color=\"#eeeeee\")\n                rad2.place(x=500, y=337.5)\n\n                rad3 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 3\", variable=radio_var2, bg_color=\"#eeeeee\")\n                rad3.place(x=500, y=475)\n\n                rad4 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 4\", variable=radio_var2, bg_color=\"#eeeeee\")\n                rad4.place(x=500, y=612.5)\n\n                rad5 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 5\", variable=radio_var2, bg_color=\"#eeeeee\")\n                rad5.place(x=500, y=750)\n\n                rad6 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 6\", variable=radio_var2, bg_color=\"white\")\n                rad6.place(x=1250, y=200)\n\n                rad7 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 7\", variable=radio_var2, bg_color=\"white\")\n                rad7.place(x=1250, y=337.5)\n\n                rad8 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 8\", variable=radio_var2, bg_color=\"white\")\n                rad8.place(x=1250, y=475)\n\n                rad9 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 9\", variable=radio_var2, bg_color=\"white\")\n                rad9.place(x=1250, y=612.5)\n\n                rad10 = CTkRadioButton(master=app, text=\" \", value=\"Custom\", variable=radio_var2, bg_color=\"white\")\n                rad10.place(x=1325, y=715)\n\n                # Creates a procedure to return to the main menu\n                def delete_picker1a():\n                    image_label2.destroy()\n                    rad1.destroy()\n                    rad2.destroy()\n                    rad3.destroy()\n                    rad4.destroy()\n                    rad5.destroy()\n                    rad6.destroy()\n                    rad7.destroy()\n                    rad8.destroy()\n                    rad9.destroy()\n                    rad10.destroy()\n                    del_btn.destroy()\n                    btn.destroy()\n                    c_dragtxt.destroy()\n\n                    deleteE1a()\n\n                # Procedure to select a drag coefficient            \n                def delete_picker2a():\n                    image_label2.destroy()\n                    rad1.destroy()\n                    rad2.destroy()\n                    rad3.destroy()\n                    rad4.destroy()\n                    rad5.destroy()\n                    rad6.destroy()\n                    rad7.destroy()\n                    rad8.destroy()\n                    rad9.destroy()\n                    rad10.destroy()\n                    del_btn.destroy()\n                    btn.destroy()\n\n                    # Obtains value for drag coefficient entered into the text field\n                    if radio_var2.get() == \"Custom\":\n                        global customc_drag\n                        customc_drag = c_dragtxt.get()                    \n                        customc_drag=float(customc_drag.rstrip(\"\\n\"))\n\n                    c_dragtxt.destroy()\n                        \n                    display()\n                    \n                c_dragtxt = CTkEntry(master=app, width=200, height=50, placeholder_text=\"Enter a custom drag coefficient\")\n                c_dragtxt.place(x=1075, y=700)\n\n                # Creates a reset button\n                del_btn = CTkButton(master=app, text=\"RETURN TO HOME\", command=delete_picker1a, width=100, height=50)\n                del_btn.pack(anchor=\"n\")\n                del_btn.place(x=1250, y=50)\n\n                # Creates a submission button\n                btn = CTkButton(master=app, text=\"SUBMIT\", command=delete_picker2a, width=100, height=50)\n                btn.pack(anchor=\"n\")\n                btn.place(x=1050, y=50)\n\n            # Defines parameters of frame1\n            frame1 = CTkFrame(master=app, border_width=2, width=250, height=300)\n            frame1.pack(anchor=\"nw\", expand=True, padx=20, pady=67)\n\n            # Defines parameters of frame2\n            frame2 = CTkFrame(master=app, border_width=2, width=250, height=250)\n            frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n            frame2.place(relx=0.014, rely=0.655)\n            \n            # Defines parameters of frame3\n            frame3 = CTkFrame(master=app, border_width=2, height=725, width=1025)\n            frame3.pack(anchor=\"n\", expand=True, padx=20)\n            frame3.place(relx=0.1875, rely=0.08)\n            \n            # Defines parameters of frame4\n            frame4 = CTkFrame(master=app, border_width=2, height=250, width=175)\n            frame4.pack(anchor=\"n\", expand=True, padx=20)\n            frame4.place(relx=0.875, rely=0.08)\n            \n            # Creates a reset button\n            del_btn = CTkButton(master=frame4, text=\"RETURN TO HOME\", command=deleteE1a, width=100, height=30)\n            del_btn.pack(anchor=\"n\")\n            del_btn.place(relx=0.175, rely=0.075)\n\n            # Function that occurs when the submit button is pressed\n            def click_handler():\n                # Determines a value for the coefficient of drag based on the user's preference\n                if radio_var2.get() == \"Projectile 1\":\n                    c_drag = 0.47\n                elif radio_var2.get() == \"Projectile 2\":\n                    c_drag = 0.42\n                elif radio_var2.get() == \"Projectile 3\":\n                    c_drag = 0.5\n                elif radio_var2.get() == \"Projectile 4\":                \n                    c_drag = 1.0\n                elif radio_var2.get() == \"Projectile 5\":\n                    c_drag = 0.8\n                elif radio_var2.get() == \"Projectile 6\":\n                    c_drag = 0.82\n                elif radio_var2.get() == \"Projectile 7\":\n                    c_drag = 1.15\n                elif radio_var2.get() == \"Projectile 8\":\n                    c_drag = 0.04\n                elif radio_var2.get() == \"Projectile 9\":\n                    c_drag = 0.09\n                elif radio_var2.get() == \"Custom\":\n                    c_drag = customc_drag\n                else:\n                    c_drag = 1\n\n                # Defines parameters of frame2\n                frame2 = CTkFrame(master=app, border_width=2, width=250, height=250)\n                frame2.pack(after=frame1, anchor=\"nw\", expand=True, padx=20)\n                frame2.place(relx=0.014, rely=0.655)\n\n                # Creates the label for the calculated valeues frame\n                label2 = CTkLabel(master=frame2, text=\"Calculated Values:\")\n                label2.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n                label2.place(relx=0.3, rely=0.05)\n                \n                # Takes parameters u, angle and h from input text fields\n                u = utxt.get()\n                angle = atxt.get()\n                h = htxt.get()\n                \n                # Sets value for g\n                g = 9.81\n                \n                # Strips the text to remove blank spaces\n                angle=float(angle.rstrip(\"\\n\"))\n                h=float(h.rstrip(\"\\n\"))\n                u=float(u.rstrip(\"\\n\"))\n                \n                # Converts the angle to radians\n                theta = (angle * np.pi) / 180\n                \n                # Produces an error if the height is less than 0\n                if h &lt; 0:\n                    exit()\n\n                # Resloves forces into horizontal and vertical component\n                costheta = math.cos(theta)\n                sintheta = math.sin(theta)\n\n                ux = u * costheta\n                uy = u * sintheta\n                \n                # Calculates the range and time of flight of the projectile\n                R = (u**2 / g) * (sintheta*costheta+costheta*math.sqrt(sintheta**2 + ((2 * g * h) / (u**2))))\n                tflight = R / (u * costheta)\n\n                # Creates an empty arrary for the x and y coordinates of the trajectory\n                x = []\n                y = []\n\n                # Plots the parabolic path of the projectile with a timestep of 0.01s across an interval of tflight\n                for i in np.arange(0, tflight, 0.01):\n                    t = i\n                    x.append(ux * t)\n                    T = t * t\n                    y.append(h + (uy * t) - (0.5 * g * T))            \n\n                # Apogee calculation\n                apy = (0 - (uy*uy)) / (2 * g * -1) + h\n                y_graph = apy + 5\n                \n                # Generates the calculated values text\n                # Time of flight phrase\n                tflightph = \"Time of flight: \" + str(round(tflight, 2)) + \" s\"\n                label5 = CTkLabel(master=frame2, text=tflightph)\n                label5.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n                label5.place(x=75, y=40)\n                    \n                # Range phrase\n                travel = \"Range: \" + str(round(R, 2)) + \" m\"    \n                label6 = CTkLabel(master=frame2, text=travel)\n                label6.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n                label6.place(relx=0.31, y=72)\n\n                # Parameters to determine k\n                m = mtxt.get()\n                A = Atxt.get()\n                dt = 0.01\n                density = 1.225\n\n                m=float(m.rstrip(\"\\n\"))\n                A=float(A.rstrip(\"\\n\"))\n\n                # Calculation for k\n                k = (0.5 * c_drag * density * A) / m\n\n                # Creates arrays for air resistance x and y values\n                x_plot = []\n                y_plot = []\n\n                # Sets initial x and y values\n                d_x = 0\n                d_y = h\n                \n                # Adds initial x and y values to the arrays\n                x_plot.append(d_x)\n                y_plot.append(d_y)\n\n                # Verlet method to update the acceleration, velocity and position of the projectile after each discrete timestep\n                n = 0\n                t_drag = 0\n                while y_plot[n] &gt;= 0:\n                    t_drag = t_drag + dt\n                    ax = - (ux / u) * k * u**2\n                    ay = - g - (uy / u) * k * u**2\n                    d_x = d_x + ux * dt + 0.5 * ax * dt**2\n                    d_y = d_y + uy * dt + 0.5 * ay * dt**2\n                    x_plot.append(d_x)\n                    y_plot.append(d_y)\n                    ux = ux + ax * dt\n                    uy = uy + ay * dt\n                    u = math.sqrt(ux**2 + uy**2)\n                    n += 1\n\n\n                R_drag = x_plot[n]\n\n                # Generates the calculated values text\n                # Time of flight phrase\n                tflightph = \"Time of flight (drag): \" + str(round(t_drag, 2)) + \" s\"\n                label5 = CTkLabel(master=frame2, text=tflightph)\n                label5.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n                label5.place(relx=0.24, y=104)\n                    \n                # Range phrase\n                travel = \"Range (drag): \" + str(round(R_drag, 2)) + \" m\"    \n                label6 = CTkLabel(master=frame2, text=travel)\n                label6.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n                label6.place(relx=0.29, y=136)\n\n                # Parameters for non linear air resistance\n                # Sea level standard atmospheric pressure\n                p0 = 101325\n                # Intial height\n                h0 = h\n                # Specific gas constant for air\n                sgc = 287.052874\n                # mass of one air molecule\n                mass_am = 4.81e-26\n                # Boltzmann constant\n                kB = 1.380649e-23\n                # Initial temperature in Celsius (standard temperature at sea level)\n                T0 = 15\n\n                x_air = 0\n                y_air = h\n\n                u = utxt.get()            \n                u=float(u.rstrip(\"\\n\"))\n                ux = u * costheta\n                uy = u * sintheta\n\n                d_x = 0\n                d_y = h\n\n                # Verlet method for varying air density\n                def verlet_air(p0, h0, sgc, mass_am, kB, T0, d_x, d_y, ux, uy, m, A, dt, c_drag, u, h, density):\n                    t = 0\n                    x_air_plot = []\n                    y_air_plot = []\n\n                    x_air_plot.append(d_x)\n                    y_air_plot.append(d_y)\n                    \n                    n = 0\n                    while y_air_plot[n] &gt;= 0:\n                        k = (0.5 * c_drag * density * A) / m\n\n                        ax = - (ux / u) * k * u**2\n                        ay = - g - (uy / u) * k * u**2\n                        d_x = d_x + ux * dt + 0.5 * ax * dt**2\n                        d_y = d_y + uy * dt + 0.5 * ay * dt**2\n                        x_air_plot.append(d_x)\n                        y_air_plot.append(d_y)\n                        ux = ux + ax * dt\n                        uy = uy + ay * dt\n                        u = math.sqrt(ux**2 + uy**2)\n                        h = d_y\n\n                        temp = T0 - h * 0.00650\n                        temp = temp + 273.15\n                        p = p0 * math.exp((-mass_am * g * h) / (kB * temp))\n                        density = p / (sgc * temp)\n\n                        n += 1\n\n                        t = t + dt\n\n                    return x_air_plot, y_air_plot, n, t\n\n                x_air_plot, y_air_plot, n, t_air = verlet_air(p0, h0, sgc, mass_am, kB, T0, x_air, y_air, ux, uy, m, A, dt, c_drag, u, h, density)\n                \n                R_air = x_air_plot[n]\n\n                # Generates the calculated values text\n                # Time of flight phrase\n                tflightph = \"Time (varying air density): \" + str(round(t_air, 2)) + \" s\"\n                label5 = CTkLabel(master=frame2, text=tflightph)\n                label5.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n                label5.place(relx=0.1, y=168)\n                    \n                # Range phrase\n                travel = \"Range (varying air density): \" + str(round(R_air, 2)) + \" m\"    \n                label6 = CTkLabel(master=frame2, text=travel)\n                label6.pack(anchor=\"center\", expand=True, pady=10, padx=100)\n                label6.place(x=25, y=200)\n\n                # Creates the figure\n                fig, ax = plt.subplots()\n\n                # Sets the parameters of the plot\n                ax.set_xlabel(\"Displacement in x / m\")\n                ax.set_ylabel(\"Displacement in y / m\")\n                ax.set_ylim(0, y_graph)\n                ax.set_xlim(0, R)\n\n                # Components to be plotted\n                ax.plot(x, y, label=\"No Air Resistance\")\n                ax.grid()\n                ax.plot(x_plot, y_plot, label=\"Air Resistance\")\n                ax.plot(x_air_plot, y_air_plot, label = \"Air Resistance and Varying Air Density\")\n\n                ax.legend()\n                \n                # Creates a canvas in the app for the plot to appear\n                canvas = FigureCanvasTkAgg(fig,master=frame3)\n                canvas.get_tk_widget().place(relx=0.012, rely=0.013, height=700, width=1000)\n                canvas.draw()\n\n                # Saves an image png of the figure when a button is pressed\n                def image_handler():\n                    path=\"/Users/Mark Watson/Desktop/Python Projects/BPHO/Projectiles\"\n                    os.chdir(path)\n                    fig.savefig(fname='Extension1.png',dpi='figure', format='png')\n                \n                # Creates a save button for png image\n                img_btn = CTkButton(master=frame4, text=\"SAVE AS PNG\", command=image_handler, width=100, height=30)\n                img_btn.pack(anchor=\"n\")\n                img_btn.place(relx=0.23, rely=0.3)\n\n            # Creates title label\n            label10 = CTkLabel(master=app, text=\"Extension: Diminishing Air Density\", font=(\"Helvetica\", 40))\n            label10.pack(anchor=\"s\", expand=True, padx=10)\n            label10.place(relx=0.3, rely=0.02)\n\n            # Creates the label for the parameters frame\n            label1 = CTkLabel(master=frame1, text=\"Enter Parameters Below:\")\n            label1.pack(anchor=\"s\", expand=True, pady=10, padx=30)\n            label1.place(relx=0.22, rely=0.05)\n\n            # Creates the label for the calculated values frame\n            label2 = CTkLabel(master=frame2, text=\"Calculated Values:\")\n            label2.pack(anchor=\"center\", expand=True, pady=10, padx=30)\n            label2.place(relx=0.3, rely=0.05)\n\n            # Creates input text fields for the parameters\n            # Initial velocity field\n            utxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Initial velocity in ms⁻¹\")\n            utxt.place(relx=0.5, rely=0.15, anchor=\"n\")\n\n            # Angle field\n            atxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Angle in °\")\n            atxt.place(relx=0.5, rely=0.275, anchor=\"n\")\n\n            # Initial height field\n            htxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Height in m\")\n            htxt.place(relx=0.5, rely=0.4, anchor=\"n\")\n\n            # Mass field\n            mtxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Mass of the projectile in kg\")\n            mtxt.place(relx=0.5, rely=0.525, anchor=\"n\")\n\n            # Area field\n            Atxt = CTkEntry(master=frame1, width=200, height=20, placeholder_text=\"Cross-sectional area in m²\")\n            Atxt.place(relx=0.5, rely=0.65, anchor=\"n\")\n\n            # Allows the user to select a different drag coefficient\n            btn = CTkButton(master=frame1, text=\"Change Drag Coefficient\", command=c_drag_picker, width=100, height=30)\n            btn.place(relx=0.2, rely=0.75)\n\n            # Creates a submission button\n            btn = CTkButton(master=frame1, text=\"Submit\", command=click_handler, width=100, height=30)\n            btn.pack(anchor=\"n\")\n            btn.place(relx=0.3, rely=0.87)\n        \n        # Creates background for menu to select projectile\n        image_path = os.path.join(os.path.dirname(__file__), 'projectile_picker.png')\n\n        projectile_picker = CTkImage(light_image = Image.open(image_path), size=(1500,825)) \n        image_label2 = CTkLabel(master=app, image = projectile_picker, text='')\n        image_label2.place(x=0, y=0)\n\n        # Creates 10 radio button options for the user to select a desireable drag coefficient\n        # Creates the radio_var2 variable to store the result of the radio button\n        global radio_var2            \n        radio_var2 = StringVar(value = \"other\")\n\n        rad1 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 1\", variable=radio_var2, bg_color=\"#eeeeee\")\n        rad1.place(x=500, y=200)\n\n        rad2 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 2\", variable=radio_var2, bg_color=\"#eeeeee\")\n        rad2.place(x=500, y=337.5)\n\n        rad3 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 3\", variable=radio_var2, bg_color=\"#eeeeee\")\n        rad3.place(x=500, y=475)\n\n        rad4 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 4\", variable=radio_var2, bg_color=\"#eeeeee\")\n        rad4.place(x=500, y=612.5)\n\n        rad5 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 5\", variable=radio_var2, bg_color=\"#eeeeee\")\n        rad5.place(x=500, y=750)\n\n        rad6 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 6\", variable=radio_var2, bg_color=\"white\")\n        rad6.place(x=1250, y=200)\n\n        rad7 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 7\", variable=radio_var2, bg_color=\"white\")\n        rad7.place(x=1250, y=337.5)\n\n        rad8 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 8\", variable=radio_var2, bg_color=\"white\")\n        rad8.place(x=1250, y=475)\n\n        rad9 = CTkRadioButton(master=app, text=\" \", value=\"Projectile 9\", variable=radio_var2, bg_color=\"white\")\n        rad9.place(x=1250, y=612.5)\n\n        rad10 = CTkRadioButton(master=app, text=\" \", value=\"Custom\", variable=radio_var2, bg_color=\"white\")\n        rad10.place(x=1325, y=715)\n\n        # Creates a procedure to return to the main menu\n        def delete_picker1():\n            image_label2.destroy()\n            rad1.destroy()\n            rad2.destroy()\n            rad3.destroy()\n            rad4.destroy()\n            rad5.destroy()\n            rad6.destroy()\n            rad7.destroy()\n            rad8.destroy()\n            rad9.destroy()\n            rad10.destroy()\n            del_btn.destroy()\n            btn.destroy()\n            c_dragtxt.destroy()\n\n            main_menu()\n\n        # Procedure to select a drag coefficient            \n        def delete_picker2():\n            image_label2.destroy()\n            rad1.destroy()\n            rad2.destroy()\n            rad3.destroy()\n            rad4.destroy()\n            rad5.destroy()\n            rad6.destroy()\n            rad7.destroy()\n            rad8.destroy()\n            rad9.destroy()\n            rad10.destroy()\n            del_btn.destroy()\n            btn.destroy()\n\n            # Obtains value for drag coefficient entered into the text field\n            if radio_var2.get() == \"Custom\":\n                global customc_drag\n                customc_drag = c_dragtxt.get()                    \n                customc_drag=float(customc_drag.rstrip(\"\\n\"))\n\n            c_dragtxt.destroy()\n                \n            display()\n            \n        c_dragtxt = CTkEntry(master=app, width=200, height=50, placeholder_text=\"Enter a custom drag coefficient\")\n        c_dragtxt.place(x=1075, y=700)\n\n        # Creates a reset button\n        del_btn = CTkButton(master=app, text=\"RETURN TO HOME\", command=delete_picker1, width=100, height=50)\n        del_btn.pack(anchor=\"n\")\n        del_btn.place(x=1250, y=50)\n\n        # Creates a submission button\n        btn = CTkButton(master=app, text=\"SUBMIT\", command=delete_picker2, width=100, height=50)\n        btn.pack(anchor=\"n\")\n        btn.place(x=1050, y=50)\n\n# Procedure to create the main menu when needed\ndef main_menu():\n    # Working directory path to the background image \n    image_path = os.path.join(os.path.dirname(__file__), 'bg.png')\n\n    # Sets the background image of the main menu\n    bg = CTkImage(light_image = Image.open(image_path), size=(1500,825))\n    global image_label \n    image_label = CTkLabel(master=app, image = bg, text='')\n    image_label.place(x=0, y=0)\n\n    # Array of challenges to select\n    challenges = [\"Challenge 1 & 2\", \"Challenge 3\", \"Challenge 4\", \"Challenge 5\", \"Challenge 6\", \"Challenge 7\", \"Challenge 8\", \"Challenge 9\", \"Extension\"]\n    # Creates a combobox to select a prefab value for g\n    global chal_combo\n    chal_combo = CTkComboBox(master=app, width=300, height=50, values=challenges, command=chal_picker, state=\"readonly\")\n    chal_combo.place(x=65, y=400)\n\n# Opens the main menu when the program is run\nmain_menu()\n\n# Generates app\napp.mainloop()"
  },
  {
    "objectID": "posts/cchallenge3.html",
    "href": "posts/cchallenge3.html",
    "title": "BPhO Computational Challenge 2024: Challenge 3: Creating a Simple Analytical Drag-Free Projectile Model",
    "section": "",
    "text": "Introduction\nDISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo .\n\n\nSetting up the Problem\nFirst, the fundamental libraries are imported. Matplotlib for plotting, numpy for mathematical and trigonometric functions, math for trigonomatric functions (specifically arctan) and figure is imported from matplotlib to use the axes functions.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\nfrom matplotlib.figure import Figure \n\nNext, the conditions / parameters of the model are set. In the final GUI application submitted for the competition, these would be inputted using text input boxes. \\(g\\) would be set using a combobox containing popular celestial objects, such as the planets in our solar system, or using a text box to enter a custom value.\n\\(Y\\) is the y coordinate that is hit by the projectile and \\(X\\) is the x coordinate.\nFor the purpose of this demonstration of the algorithm, I have used the below values.\n\nX = 1000\nY = 300\nu = 150\ng = 9.81\n\nThe problem must be decomposed into three separate problems. The first problem is the minimum velocity projectile. There are equations which can be used to calculate the minimum velocity and the corresponding angle of projection for the model. The second and third problems consist of the low and high ball trajectories. These can also be computed using equations.\n\n\nMinimum Launch Velocity\nThe minimum launch velocity must be calculated. This is achieved using the equation \\(u_{min}\\sqrt{g}\\sqrt{Y + \\sqrt{X^2 + Y^2}}\\).\nNow, the corresponding angle of projection must be calculated using \\(\\theta_{min}=\\tan^{-1}\\). Finally, the velocity of the projectile is\n\nminu = np.sqrt(g) * (np.sqrt(Y + np.sqrt(X**2 + Y**2)))\nmintheta = math.atan((Y + np.sqrt(X**2 + Y**2)) / X)\nminux = minu * np.cos(mintheta)\nminuy = minu * np.sin(mintheta)\nmint = X / minux\n\n\nx = []\ny = []\n\nfor i in np.arange(0, mint, 0.01):\n    t = i\n    x.append(minux * t)\n    T = t**2\n    y.append((minuy * t) - (0.5 * g * T))\n\n\n\nLow and High Ball Trajectories\n\na = (g / (2 * u**2)) * X**2\nb =  -X\nc = Y + ((g * X**2)/(2 * u**2))\nlow_theta = math.atan((- b - np.sqrt(b**2 - (4 * a * c)))/(2 * a))\nhigh_theta = math.atan((- b + np.sqrt(b**2 - (4 * a * c)))/(2 * a))\n\n\nlow_ux = u * np.cos(low_theta)\nlow_uy = u * np.sin(low_theta)\nlow_tflight = X / low_ux\n\n\nlow_x = []\nlow_y = []\n\nfor low_i in np.arange(0, low_tflight, 0.01):\n    low_t = low_i\n    low_x.append(low_ux * low_t)\n    low_T = low_t**2\n    low_y.append((low_uy * low_t) - (0.5 * g * low_T))\n\n\nhigh_ux = u * np.cos(high_theta)\nhigh_uy = u * np.sin(high_theta)\nhigh_tflight = X / high_ux\n\n\nhigh_x = []\nhigh_y = []\n\nfor high_i in np.arange(0, high_tflight, 0.01):\n    high_t = high_i\n    high_x.append(high_ux * high_t)\n    high_T = high_t**2\n    high_y.append((high_uy * high_t) - (0.5 * g * high_T))\n\n\n\nPlotting the Trajectories\n\nfig, ax = plt.subplots()\n\nax.plot(x, y)\nax.plot(low_x, low_y)\nax.plot(high_x, high_y)\nax.scatter(X, Y, marker=\"x\", color=\"red\")\n\nax.set_xlabel(\"Displacement in x / m\")\nax.set_ylabel(\"Displacement in y / m\")\nax.set_ylim(0)\nax.set_xlim(0, X)"
  },
  {
    "objectID": "posts/cchallenge6.html",
    "href": "posts/cchallenge6.html",
    "title": "BPhO Computational Challenge 2024: Challenge 6: Calculating the Distance Travelled by a Drag-Free Projectile using Integration",
    "section": "",
    "text": "DISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo ."
  },
  {
    "objectID": "posts/cchallenge8.html",
    "href": "posts/cchallenge8.html",
    "title": "BPhO Computational Challenge 2024: Challenge 8: Bouncing Projectile Model",
    "section": "",
    "text": "DISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo ."
  },
  {
    "objectID": "posts/cchallengee1.html",
    "href": "posts/cchallengee1.html",
    "title": "BPhO Computational Challenge 2024: Extension: Creating a Projectile Model Incorporating both Air Resistance and Varying Air Density with Height",
    "section": "",
    "text": "DISCLAIMER: This is just a snippet of our submission for the competition, since the final product was an application 2800 lines of code in length. To see the two minute video submission detailing the entire solution with my partner watch the video here:  https://youtu.be/ViT6NdrrbJo ."
  }
]